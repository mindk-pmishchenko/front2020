{"version":3,"file":"react-query.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../src/core/subscribable.ts","../node_modules/@babel/runtime/helpers/esm/extends.js","../src/core/utils.ts","../src/core/focusManager.ts","../src/core/onlineManager.ts","../src/core/retryer.ts","../src/core/notifyManager.ts","../src/core/logger.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/mutation.ts","../src/core/mutationCache.ts","../src/core/infiniteQueryBehavior.ts","../src/core/queryClient.ts","../src/core/queryObserver.ts","../src/core/queriesObserver.ts","../src/core/infiniteQueryObserver.ts","../src/core/mutationObserver.ts","../src/react/QueryClientProvider.tsx","../src/react/QueryErrorResetBoundary.tsx","../src/react/useBaseQuery.ts","../src/react/useInfiniteQuery.ts","../src/react/useIsFetching.ts","../src/react/useMutation.ts","../src/react/useQueries.ts","../src/react/useQuery.ts"],"sourcesContent":["export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener?: TListener): () => void {\n    const callback = listener || (() => undefined)\n\n    this.listeners.push(callback as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== callback)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { Query } from './query'\nimport type {\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Include or exclude active queries\n   */\n  active?: boolean\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include or exclude inactive queries\n   */\n  inactive?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include or exclude fetching queries\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: any): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function ensureArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value]\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter(x => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<TOptions extends QueryOptions<any, any, any>>(\n  arg1: QueryKey | TOptions,\n  arg2?: QueryFunction<any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, queryKey: arg1 }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any>\n): boolean {\n  const {\n    active,\n    exact,\n    fetching,\n    inactive,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  let isActive\n\n  if (inactive === false || (active && !inactive)) {\n    isActive = true\n  } else if (active === false || (inactive && !active)) {\n    isActive = false\n  }\n\n  if (typeof isActive === 'boolean' && query.isActive() !== isActive) {\n    return false\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions(\n  queryKey: QueryKey,\n  options?: QueryOptions<any, any>\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  const asArray = Array.isArray(queryKey) ? queryKey : [queryKey]\n  return stableValueHash(asArray)\n}\n\n/**\n * Hashes the value into a stable hash.\n */\nexport function stableValueHash(value: any): string {\n  return JSON.stringify(value, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(\n  a: string | unknown[],\n  b: string | unknown[]\n): boolean {\n  return partialDeepEqual(ensureArray(a), ensureArray(b))\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: any): value is QueryKey {\n  return typeof value === 'string' || Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass FocusManager extends Subscribable {\n  private focused?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (onFocus: () => void) => (focused?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((focused?: boolean) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState\n    )\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onFocus => {\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', onFocus, false)\n        window.addEventListener('focus', onFocus, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', onFocus)\n          window.removeEventListener('focus', onFocus)\n        }\n      })\n    }\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass OnlineManager extends Subscribable {\n  private online?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (setOnline: () => void) => (online?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onOnline => {\n        // Listen to online\n        window.addEventListener('online', onOnline, false)\n        window.addEventListener('offline', onOnline, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onOnline)\n          window.removeEventListener('offline', onOnline)\n        }\n      })\n    }\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { functionalUpdate, sleep } from './utils'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError\n) => boolean\n\nexport type RetryDelayValue = number | RetryDelayFunction\n\ntype RetryDelayFunction = (failureCount: number) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\n// CLASS\n\nexport class Retryer<TData = unknown, TError = unknown> {\n  cancel: (options?: CancelOptions) => void\n  cancelRetry: () => void\n  continue: () => void\n  failureCount: number\n  isPaused: boolean\n  isResolved: boolean\n  isTransportCancelable: boolean\n  promise: Promise<TData>\n\n  constructor(config: RetryerConfig<TData, TError>) {\n    let cancelRetry = false\n    let cancelFn: ((options?: CancelOptions) => void) | undefined\n    let continueFn: ((value?: unknown) => void) | undefined\n    let promiseResolve: (data: TData) => void\n    let promiseReject: (error: TError) => void\n\n    this.cancel = cancelOptions => cancelFn?.(cancelOptions)\n    this.cancelRetry = () => {\n      cancelRetry = true\n    }\n    this.continue = () => continueFn?.()\n    this.failureCount = 0\n    this.isPaused = false\n    this.isResolved = false\n    this.isTransportCancelable = false\n    this.promise = new Promise<TData>((outerResolve, outerReject) => {\n      promiseResolve = outerResolve\n      promiseReject = outerReject\n    })\n\n    const resolve = (value: any) => {\n      if (!this.isResolved) {\n        this.isResolved = true\n        config.onSuccess?.(value)\n        continueFn?.()\n        promiseResolve(value)\n      }\n    }\n\n    const reject = (value: any) => {\n      if (!this.isResolved) {\n        this.isResolved = true\n        config.onError?.(value)\n        continueFn?.()\n        promiseReject(value)\n      }\n    }\n\n    const pause = () => {\n      return new Promise(continueResolve => {\n        continueFn = continueResolve\n        this.isPaused = true\n        config.onPause?.()\n      }).then(() => {\n        continueFn = undefined\n        this.isPaused = false\n        config.onContinue?.()\n      })\n    }\n\n    // Create loop function\n    const run = () => {\n      // Do nothing if already resolved\n      if (this.isResolved) {\n        return\n      }\n\n      let promiseOrValue: any\n\n      // Execute query\n      try {\n        promiseOrValue = config.fn()\n      } catch (error) {\n        promiseOrValue = Promise.reject(error)\n      }\n\n      // Create callback to cancel this fetch\n      cancelFn = cancelOptions => {\n        if (!this.isResolved) {\n          reject(new CancelledError(cancelOptions))\n\n          // Cancel transport if supported\n          if (isCancelable(promiseOrValue)) {\n            try {\n              promiseOrValue.cancel()\n            } catch {}\n          }\n        }\n      }\n\n      // Check if the transport layer support cancellation\n      this.isTransportCancelable = isCancelable(promiseOrValue)\n\n      Promise.resolve(promiseOrValue)\n        .then(resolve)\n        .catch(error => {\n          // Stop if the fetch is already resolved\n          if (this.isResolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const retry = config.retry ?? 3\n          const retryDelay = config.retryDelay ?? defaultRetryDelay\n          const delay = functionalUpdate(retryDelay, this.failureCount) || 0\n          const shouldRetry =\n            retry === true ||\n            (typeof retry === 'number' && this.failureCount < retry) ||\n            (typeof retry === 'function' && retry(this.failureCount, error))\n\n          if (cancelRetry || !shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          this.failureCount++\n\n          // Notify on fail\n          config.onFail?.(this.failureCount, error)\n\n          // Delay\n          sleep(delay)\n            // Pause if the document is not visible or when the device is offline\n            .then(() => {\n              if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n                return pause()\n              }\n            })\n            .then(() => {\n              if (cancelRetry) {\n                reject(error)\n              } else {\n                run()\n              }\n            })\n        })\n    }\n\n    // Start loop\n    run()\n  }\n}\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\n// CLASS\n\nclass NotifyManager {\n  private queue: NotifyCallback[]\n  private transactions: number\n  private notifyFn: NotifyFunction\n  private batchNotifyFn: BatchNotifyFunction\n\n  constructor() {\n    this.queue = []\n    this.transactions = 0\n\n    this.notifyFn = (callback: () => void) => {\n      callback()\n    }\n\n    this.batchNotifyFn = (callback: () => void) => {\n      callback()\n    }\n  }\n\n  batch<T>(callback: () => T): T {\n    this.transactions++\n    const result = callback()\n    this.transactions--\n    if (!this.transactions) {\n      this.flush()\n    }\n    return result\n  }\n\n  schedule(callback: NotifyCallback): void {\n    if (this.transactions) {\n      this.queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        this.notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  batchCalls<T extends Function>(callback: T): T {\n    return ((...args: any[]) => {\n      this.schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  flush(): void {\n    const queue = this.queue\n    this.queue = []\n    if (queue.length) {\n      scheduleMicrotask(() => {\n        this.batchNotifyFn(() => {\n          queue.forEach(callback => {\n            this.notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  setNotifyFunction(fn: NotifyFunction) {\n    this.notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  setBatchNotifyFunction(fn: BatchNotifyFunction) {\n    this.batchNotifyFn = fn\n  }\n}\n\n// SINGLETON\n\nexport const notifyManager = new NotifyManager()\n","import { noop } from './utils'\n\n// TYPES\n\nexport interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\n// FUNCTIONS\n\nlet logger: Logger = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function getLogger(): Logger {\n  return logger\n}\n\nexport function setLogger(newLogger: Logger) {\n  logger = newLogger\n}\n","import {\n  Updater,\n  ensureArray,\n  functionalUpdate,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  timeUntilStale,\n} from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport { notifyManager } from './notifyManager'\nimport { getLogger } from './logger'\nimport { Retryer, CancelOptions, isCancelledError } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<TQueryFnData, TError, TData> {\n  cache: QueryCache\n  queryKey: QueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchMeta: any\n  isFetching: boolean\n  isInvalidated: boolean\n  isPaused: boolean\n  status: QueryStatus\n}\n\nexport interface FetchContext<TQueryFnData, TError, TData> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  options: QueryOptions<TQueryFnData, TError, TData>\n  queryKey: QueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  onFetch: (context: FetchContext<TQueryFnData, TError, TData>) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: QueryState<TData, TError>\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  queryKey: QueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  cacheTime!: number\n\n  private cache: QueryCache\n  private promise?: Promise<TData>\n  private gcTimeout?: number\n  private retryer?: Retryer<TData, TError>\n  private observers: QueryObserver<any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData>) {\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || this.getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData>\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    // Default to 5 minutes if not cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      this.options.cacheTime ?? 5 * 60 * 1000\n    )\n  }\n\n  setDefaultOptions(options: QueryOptions<TQueryFnData, TError, TData>): void {\n    this.defaultOptions = options\n  }\n\n  private scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  private clearGcTimeout() {\n    clearTimeout(this.gcTimeout)\n    this.gcTimeout = undefined\n  }\n\n  private optionalRemove() {\n    if (!this.observers.length && !this.state.isFetching) {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data = functionalUpdate(updater, prevData)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.options.isDataEqual?.(prevData, data)) {\n      data = prevData as TData\n    } else if (this.options.structuralSharing !== false) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n    })\n\n    return data\n  }\n\n  setState(state: QueryState<TData, TError>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.options.enabled !== false)\n  }\n\n  isFetching(): boolean {\n    return this.state.isFetching\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some(observer => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify(this)\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.retryer.isTransportCancelable) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        if (this.cacheTime) {\n          this.scheduleGc()\n        } else {\n          this.cache.remove(this)\n        }\n      }\n\n      this.cache.notify(this)\n    }\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData>,\n    fetchOptions?: FetchOptions\n  ): Promise<TData> {\n    if (this.state.isFetching) {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    // Create query function context\n    const queryKey = ensureArray(this.queryKey)\n    const queryFnContext: QueryFunctionContext = {\n      queryKey,\n      pageParam: undefined,\n    }\n\n    // Create fetch function\n    const fetchFn = () =>\n      this.options.queryFn\n        ? this.options.queryFn(queryFnContext)\n        : Promise.reject('Missing queryFn')\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData> = {\n      fetchOptions,\n      options: this.options,\n      queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    if (this.options.behavior?.onFetch) {\n      this.options.behavior?.onFetch(context)\n    }\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      !this.state.isFetching ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.retryer = new Retryer({\n      fn: context.fetchFn as () => TData,\n      onSuccess: data => {\n        this.setData(data as TData)\n\n        // Remove query after fetching if cache time is 0\n        if (this.cacheTime === 0) {\n          this.optionalRemove()\n        }\n      },\n      onError: error => {\n        // Optimistically update state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          this.dispatch({\n            type: 'error',\n            error: error as TError,\n          })\n        }\n\n        if (!isCancelledError(error)) {\n          // Notify cache callback\n          if (this.cache.config.onError) {\n            this.cache.config.onError(error, this as Query)\n          }\n\n          // Log error\n          getLogger().error(error)\n        }\n\n        // Remove query after fetching if cache time is 0\n        if (this.cacheTime === 0) {\n          this.optionalRemove()\n        }\n      },\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    this.state = this.reducer(this.state, action)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify(this)\n    })\n  }\n\n  protected getDefaultState(\n    options: QueryOptions<TQueryFnData, TError, TData>\n  ): QueryState<TData, TError> {\n    const data =\n      typeof options.initialData === 'function'\n        ? (options.initialData as InitialDataFunction<TData>)()\n        : options.initialData\n\n    const hasInitialData = typeof options.initialData !== 'undefined'\n\n    const initialDataUpdatedAt = hasInitialData\n      ? typeof options.initialDataUpdatedAt === 'function'\n        ? (options.initialDataUpdatedAt as () => number | undefined)()\n        : options.initialDataUpdatedAt\n      : 0\n\n    const hasData = typeof data !== 'undefined'\n\n    return {\n      data,\n      dataUpdateCount: 0,\n      dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n      error: null,\n      errorUpdateCount: 0,\n      errorUpdatedAt: 0,\n      fetchFailureCount: 0,\n      fetchMeta: null,\n      isFetching: false,\n      isInvalidated: false,\n      isPaused: false,\n      status: hasData ? 'success' : 'idle',\n    }\n  }\n\n  protected reducer(\n    state: QueryState<TData, TError>,\n    action: Action<TData, TError>\n  ): QueryState<TData, TError> {\n    switch (action.type) {\n      case 'failed':\n        return {\n          ...state,\n          fetchFailureCount: state.fetchFailureCount + 1,\n        }\n      case 'pause':\n        return {\n          ...state,\n          isPaused: true,\n        }\n      case 'continue':\n        return {\n          ...state,\n          isPaused: false,\n        }\n      case 'fetch':\n        return {\n          ...state,\n          fetchFailureCount: 0,\n          fetchMeta: action.meta ?? null,\n          isFetching: true,\n          isPaused: false,\n          status: !state.dataUpdatedAt ? 'loading' : state.status,\n        }\n      case 'success':\n        return {\n          ...state,\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n          error: null,\n          fetchFailureCount: 0,\n          isFetching: false,\n          isInvalidated: false,\n          isPaused: false,\n          status: 'success',\n        }\n      case 'error':\n        const error = action.error as unknown\n\n        if (isCancelledError(error) && error.revert && this.revertState) {\n          return { ...this.revertState }\n        }\n\n        return {\n          ...state,\n          error: error as TError,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          isFetching: false,\n          isPaused: false,\n          status: 'error',\n        }\n      case 'invalidate':\n        return {\n          ...state,\n          isInvalidated: true,\n        }\n      case 'setState':\n        return {\n          ...state,\n          ...action.state,\n        }\n      default:\n        return state\n    }\n  }\n}\n","import {\n  QueryFilters,\n  hashQueryKeyByOptions,\n  matchQuery,\n  parseFilterArgs,\n} from './utils'\nimport { Query, QueryState } from './query'\nimport type { QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (query?: Query) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData>,\n    state?: QueryState<TData, TError>\n  ): Query<TQueryFnData, TError, TData> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify(query)\n    }\n  }\n\n  remove(query: Query<any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter(x => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify(query)\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryHash: string\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find(query => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return filters\n      ? this.queries.filter(query => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(query?: Query<any, any>) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(query)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport { getLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Retryer } from './retryer'\nimport { noop } from './utils'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private mutationCache: MutationCache\n  private retryer?: Retryer<TData, TError>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    this.options = {\n      ...config.defaultOptions,\n      ...config.options,\n    }\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.observers = []\n    this.state = config.state || getDefaultState()\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n  }\n\n  cancel(): Promise<void> {\n    if (this.retryer) {\n      this.retryer.cancel()\n      return this.retryer.promise.then(noop).catch(noop)\n    }\n    return Promise.resolve()\n  }\n\n  continue(): Promise<TData> {\n    if (this.retryer) {\n      this.retryer.continue()\n      return this.retryer.promise\n    }\n    return this.execute()\n  }\n\n  execute(): Promise<TData> {\n    let data: TData\n\n    const restored = this.state.status === 'loading'\n\n    let promise = Promise.resolve()\n\n    if (!restored) {\n      this.dispatch({ type: 'loading', variables: this.options.variables! })\n      promise = promise\n        .then(() => this.options.onMutate?.(this.state.variables!))\n        .then(context => {\n          if (context !== this.state.context) {\n            this.dispatch({\n              type: 'loading',\n              context,\n              variables: this.state.variables,\n            })\n          }\n        })\n    }\n\n    return promise\n      .then(() => this.executeMutation())\n      .then(result => {\n        data = result\n      })\n      .then(() =>\n        this.options.onSuccess?.(\n          data,\n          this.state.variables!,\n          this.state.context!\n        )\n      )\n      .then(() =>\n        this.options.onSettled?.(\n          data,\n          null,\n          this.state.variables!,\n          this.state.context\n        )\n      )\n      .then(() => {\n        this.dispatch({ type: 'success', data })\n        return data\n      })\n      .catch(error => {\n        // Notify cache callback\n        if (this.mutationCache.config.onError) {\n          this.mutationCache.config.onError(\n            error,\n            this.state.variables,\n            this.state.context,\n            this as Mutation<unknown, unknown, unknown, unknown>\n          )\n        }\n\n        // Log error\n        getLogger().error(error)\n\n        return Promise.resolve()\n          .then(() =>\n            this.options.onError?.(\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() =>\n            this.options.onSettled?.(\n              undefined,\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() => {\n            this.dispatch({ type: 'error', error })\n            throw error\n          })\n      })\n  }\n\n  private executeMutation(): Promise<TData> {\n    this.retryer = new Retryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject('No mutationFn found')\n        }\n        return this.options.mutationFn(this.state.variables!)\n      },\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n    })\n\n    return this.retryer.promise\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    this.state = reducer(this.state, action)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify(this)\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n\nfunction reducer<TData, TError, TVariables, TContext>(\n  state: MutationState<TData, TError, TVariables, TContext>,\n  action: Action<TData, TError, TVariables, TContext>\n): MutationState<TData, TError, TVariables, TContext> {\n  switch (action.type) {\n    case 'failed':\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case 'pause':\n      return {\n        ...state,\n        isPaused: true,\n      }\n    case 'continue':\n      return {\n        ...state,\n        isPaused: false,\n      }\n    case 'loading':\n      return {\n        ...state,\n        context: action.context,\n        data: undefined,\n        error: null,\n        isPaused: false,\n        status: 'loading',\n        variables: action.variables,\n      }\n    case 'success':\n      return {\n        ...state,\n        data: action.data,\n        error: null,\n        status: 'success',\n        isPaused: false,\n      }\n    case 'error':\n      return {\n        ...state,\n        data: undefined,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isPaused: false,\n        status: 'error',\n      }\n    case 'setState':\n      return {\n        ...state,\n        ...action.state,\n      }\n    default:\n      return state\n  }\n}\n","import type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport { Mutation, MutationState } from './mutation'\nimport { noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown, unknown>\n  ) => void\n}\n\ntype MutationCacheListener = (mutation?: Mutation) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify(mutation)\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter(x => x !== mutation)\n    mutation.cancel()\n    this.notify(mutation)\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  notify(mutation?: Mutation<any, any, any, any>) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(mutation)\n      })\n    })\n  }\n\n  onFocus(): void {\n    this.resumePausedMutations()\n  }\n\n  onOnline(): void {\n    this.resumePausedMutations()\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused)\n    return notifyManager.batch(() =>\n      pausedMutations.reduce(\n        (promise, mutation) =>\n          promise.then(() => mutation.continue().catch(noop)),\n        Promise.resolve()\n      )\n    )\n  }\n}\n","import type { QueryBehavior } from './query'\nimport { isCancelable } from './retryer'\nimport type { InfiniteData, QueryFunctionContext, QueryOptions } from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n          }\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then(page => {\n            newPageParams = previous\n              ? [param, ...newPageParams]\n              : [...newPageParams, param]\n            return previous ? [page, ...pages] : [...pages, page]\n          })\n\n          if (isCancelable(queryFnResult)) {\n            const promiseAsAny = promise as any\n            promiseAsAny.cancel = queryFnResult.cancel\n          }\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          // Fetch first page\n          promise = fetchPage([], manual, oldPageParams[0])\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const param = manual\n                ? oldPageParams[i]\n                : getNextPageParam(context.options, pages)\n              return fetchPage(pages, manual, param)\n            })\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        const finalPromiseAsAny = finalPromise as any\n\n        finalPromiseAsAny.cancel = () => {\n          cancelled = true\n          if (isCancelable(promise)) {\n            promise.cancel()\n          }\n        }\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n}\n","import {\n  QueryFilters,\n  Updater,\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n} from './utils'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  ResetOptions,\n} from './types'\nimport type { QueryState, SetDataOptions } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { CancelOptions } from './retryer'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\n\n// TYPES\n\ninterface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onFocus()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onOnline()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetching = true\n    return this.queryCache.findAll(filters).length\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): TData | undefined {\n    return this.queryCache.find<TData>(queryKey, filters)?.state.data\n  }\n\n  setQueryData<TData>(\n    queryKey: QueryKey,\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(updater, options)\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): QueryState<TData, TError> | undefined {\n    return this.queryCache.find<TData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void>\n  resetQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: ResetOptions\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | ResetOptions,\n    arg3?: ResetOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: true,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions))\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: filters.refetchActive ?? true,\n      inactive: filters.refetchInactive ?? false,\n    }\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries(\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | RefetchOptions,\n    arg3?: RefetchOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache.findAll(filters).map(query => query.fetch())\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    options: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKey | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery(options: FetchQueryOptions): Promise<void>\n  prefetchQuery(queryKey: QueryKey, options?: FetchQueryOptions): Promise<void>\n  prefetchQuery(\n    queryKey: QueryKey,\n    queryFn: QueryFunction,\n    options?: FetchQueryOptions\n  ): Promise<void>\n  prefetchQuery(\n    arg1: QueryKey | FetchQueryOptions,\n    arg2?: QueryFunction | FetchQueryOptions,\n    arg3?: FetchQueryOptions\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKey | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery(options: FetchInfiniteQueryOptions): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKey,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKey,\n    queryFn: QueryFunction,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    arg1: QueryKey | FetchInfiniteQueryOptions,\n    arg2?: QueryFunction | FetchInfiniteQueryOptions,\n    arg3?: FetchInfiniteQueryOptions\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  cancelMutations(): Promise<void> {\n    const promises = notifyManager.batch(() =>\n      this.mutationCache.getAll().map(mutation => mutation.cancel())\n    )\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.getMutationCache().resumePausedMutations()\n  }\n\n  executeMutation<\n    TData = unknown,\n    TError = unknown,\n    TVariables = void,\n    TContext = unknown\n  >(\n    options: MutationOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    return this.mutationCache.build(this, options).execute()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.queryDefaults.find(\n      x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey\n  ): QueryObserverOptions<any, any, any, any> | undefined {\n    return queryKey\n      ? this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey))\n          ?.defaultOptions\n      : undefined\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.mutationDefaults.find(\n      x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return mutationKey\n      ? this.mutationDefaults.find(x =>\n          partialMatchKey(mutationKey, x.mutationKey)\n        )?.defaultOptions\n      : undefined\n  }\n\n  defaultQueryOptions<T extends QueryOptions<any, any, any>>(options?: T): T {\n    if (options?._defaulted) {\n      return options\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    } as T\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      )\n    }\n\n    return defaultedOptions\n  }\n\n  defaultQueryObserverOptions<\n    T extends QueryObserverOptions<any, any, any, any>\n  >(options?: T): T {\n    return this.defaultQueryOptions(options)\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n  ResultOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { getLogger } from './logger'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n  private trackedProps!: Array<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = []\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOnReconnect(this.currentQuery, this.options)\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOnWindowFocus(this.currentQuery, this.options)\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearTimers()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n    notifyOptions?: NotifyOptions\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryObserverOptions(options)\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.refetchInterval !== prevOptions.refetchInterval)\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  getOptimisticResult(\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ): QueryObserverResult<TData, TError> {\n    const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(\n        this.client,\n        defaultedOptions as QueryOptions<TQueryFnData, TError, TQueryData>\n      )\n\n    return this.createResult(query, defaultedOptions)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          const typedKey = key as keyof QueryObserverResult\n          if (!this.trackedProps.includes(typedKey)) {\n            this.trackedProps.push(typedKey)\n          }\n          return result[typedKey]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getNextResult(\n    options?: ResultOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return new Promise((resolve, reject) => {\n      const unsubscribe = this.subscribe(result => {\n        if (!result.isFetching) {\n          unsubscribe()\n          if (result.isError && options?.throwOnError) {\n            reject(result.error)\n          } else {\n            resolve(result)\n          }\n        }\n      })\n    })\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch(\n    options?: RefetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.fetch(options)\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(\n        this.client,\n        defaultedOptions as QueryOptions<TQueryFnData, TError, TQueryData>\n      )\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch(fetchOptions).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData>,\n      fetchOptions\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    this.clearRefetchInterval()\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.options.refetchInterval)\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.options.refetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  private clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    clearTimeout(this.staleTimeoutId)\n    this.staleTimeoutId = undefined\n  }\n\n  private clearRefetchInterval(): void {\n    clearInterval(this.refetchIntervalId)\n    this.refetchIntervalId = undefined\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData>,\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, isFetching, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options.optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        isFetching = true\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdateCount &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === prevResultOptions?.select\n      ) {\n        data = prevResult.data\n      } else {\n        try {\n          data = options.select(state.data)\n          if (options.structuralSharing !== false) {\n            data = replaceEqualDeep(prevResult?.data, data)\n          }\n        } catch (selectError) {\n          getLogger().error(selectError)\n          error = selectError\n          errorUpdatedAt = Date.now()\n          status = 'error'\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = (state.data as unknown) as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TData>)()\n            : options.placeholderData\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = placeholderData\n        isPlaceholderData = true\n      }\n    }\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      isIdle: status === 'idle',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  private shouldNotifyListeners(\n    result: QueryObserverResult,\n    prevResult?: QueryObserverResult\n  ): boolean {\n    if (!prevResult) {\n      return true\n    }\n\n    if (result === prevResult) {\n      return false\n    }\n\n    const { notifyOnChangeProps, notifyOnChangePropsExclusions } = this.options\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true\n    }\n\n    if (notifyOnChangeProps === 'tracked' && !this.trackedProps.length) {\n      return true\n    }\n\n    const includedProps =\n      notifyOnChangeProps === 'tracked'\n        ? this.trackedProps\n        : notifyOnChangeProps\n\n    return Object.keys(result).some(key => {\n      const typedKey = key as keyof QueryObserverResult\n      const changed = result[typedKey] !== prevResult[typedKey]\n      const isIncluded = includedProps?.some(x => x === key)\n      const isExcluded = notifyOnChangePropsExclusions?.some(x => x === key)\n      return changed && !isExcluded && (!includedProps || isIncluded)\n    })\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    this.currentResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify if something has changed\n    if (shallowEqualObjects(this.currentResult, prevResult)) {\n      return\n    }\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    if (\n      notifyOptions?.listeners !== false &&\n      this.shouldNotifyListeners(this.currentResult, prevResult)\n    ) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client\n      .getQueryCache()\n      .build(\n        this.client,\n        this.options as QueryOptions<TQueryFnData, TError, TQueryData>\n      )\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify(this.currentQuery)\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any>,\n  options: QueryObserverOptions<any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldRefetchOnMount(\n  query: Query<any, any>,\n  options: QueryObserverOptions<any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    query.state.dataUpdatedAt > 0 &&\n    (options.refetchOnMount === 'always' ||\n      (options.refetchOnMount !== false && isStale(query, options)))\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any>,\n  options: QueryObserverOptions<any, any>\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) || shouldRefetchOnMount(query, options)\n  )\n}\n\nfunction shouldFetchOnReconnect(\n  query: Query<any, any>,\n  options: QueryObserverOptions<any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    (options.refetchOnReconnect === 'always' ||\n      (options.refetchOnReconnect !== false && isStale(query, options)))\n  )\n}\n\nfunction shouldFetchOnWindowFocus(\n  query: Query<any, any>,\n  options: QueryObserverOptions<any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    (options.refetchOnWindowFocus === 'always' ||\n      (options.refetchOnWindowFocus !== false && isStale(query, options)))\n  )\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any>,\n  prevQuery: Query<any, any>,\n  options: QueryObserverOptions<any, any>,\n  prevOptions: QueryObserverOptions<any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any>,\n  options: QueryObserverOptions<any, any>\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n","import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type { QueryObserverOptions, QueryObserverResult } from './types'\nimport type { QueryClient } from './queryClient'\nimport { NotifyOptions, QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach(observer => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions\n  ): void {\n    this.queries = queries\n    this.updateObservers(notifyOptions)\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return queries.map(options => {\n      const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n      return this.getObserver(defaultedOptions).getOptimisticResult(\n        defaultedOptions\n      )\n    })\n  }\n\n  private getObserver(options: QueryObserverOptions): QueryObserver {\n    const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n    return (\n      this.observersMap[defaultedOptions.queryHash!] ||\n      new QueryObserver(this.client, defaultedOptions)\n    )\n  }\n\n  private updateObservers(notifyOptions?: NotifyOptions): void {\n    notifyManager.batch(() => {\n      let hasIndexChange = false\n\n      const prevObservers = this.observers\n      const prevOberversMap = this.observersMap\n\n      const newResult: QueryObserverResult[] = []\n      const newObservers: QueryObserver[] = []\n      const newObserversMap: Record<string, QueryObserver> = {}\n\n      this.queries.forEach((options, i) => {\n        const defaultedOptions = this.client.defaultQueryObserverOptions(\n          options\n        )\n        const queryHash = defaultedOptions.queryHash!\n        const observer = this.getObserver(defaultedOptions)\n\n        if (prevOberversMap[queryHash]) {\n          observer.setOptions(defaultedOptions, notifyOptions)\n        }\n\n        if (observer !== prevObservers[i]) {\n          hasIndexChange = true\n        }\n\n        newObservers.push(observer)\n        newResult.push(observer.getCurrentResult())\n        newObserversMap[queryHash] = observer\n      })\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result)\n      })\n    })\n  }\n}\n","import type {\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport { ObserverFetchOptions, QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions?: ObserverFetchOptions\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): void {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior<TQueryFnData, TError, TData>(),\n    })\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, InfiniteData<TQueryData>>,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(options, state.data?.pages),\n      isFetchingNextPage:\n        state.isFetching && state.fetchMeta?.fetchMore?.direction === 'forward',\n      isFetchingPreviousPage:\n        state.isFetching &&\n        state.fetchMeta?.fetchMore?.direction === 'backward',\n    }\n  }\n}\n","import { Action, getDefaultState, Mutation } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    this.options = this.client.defaultMutationOptions(options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.currentResult = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","import React from 'react'\n\nimport { QueryClient } from '../core'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nconst defaultContext = React.createContext<QueryClient | undefined>(undefined)\n\n// We share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext() {\n  // @ts-ignore (for global)\n  if (typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = () => {\n  const queryClient = React.useContext(getQueryClientContext())\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\nexport interface QueryClientProviderProps {\n  client: QueryClient\n}\n\nexport const QueryClientProvider: React.FC<QueryClientProviderProps> = ({\n  client,\n  children,\n}) => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext()\n\n  return <Context.Provider value={client}>{children}</Context.Provider>\n}\n","import React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary: React.FC<QueryErrorResetBoundaryProps> = ({\n  children,\n}) => {\n  const value = React.useMemo(() => createValue(), [])\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { notifyManager } from '../core/notifyManager'\nimport { QueryObserver } from '../core/queryObserver'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<TQueryFnData, TError, TData, TQueryData>(\n  options: UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryData>,\n  Observer: typeof QueryObserver\n) {\n  const mountedRef = React.useRef(false)\n  const [, forceUpdate] = React.useState(0)\n\n  const queryClient = useQueryClient()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryObserverOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions.optimisticResults = true\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const obsRef = React.useRef<QueryObserver<any, any>>()\n\n  if (!obsRef.current) {\n    obsRef.current = new Observer(queryClient, defaultedOptions)\n  }\n\n  let result = obsRef.current.getOptimisticResult(defaultedOptions)\n\n  React.useEffect(() => {\n    mountedRef.current = true\n\n    errorResetBoundary.clearReset()\n\n    const unsubscribe = obsRef.current!.subscribe(\n      notifyManager.batchCalls(() => {\n        if (mountedRef.current) {\n          forceUpdate(x => x + 1)\n        }\n      })\n    )\n\n    // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n    obsRef.current!.updateResult()\n\n    return () => {\n      mountedRef.current = false\n      unsubscribe()\n    }\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    obsRef.current!.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions])\n\n  // Handle suspense\n  if (defaultedOptions.suspense && result.isLoading) {\n    throw obsRef.current\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch(error => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) &&\n    result.isError\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  if (defaultedOptions.notifyOnChangeProps === 'tracked') {\n    result = obsRef.current.trackResult(result)\n  }\n\n  return result\n}\n","import { QueryObserver } from '../core'\nimport { InfiniteQueryObserver } from '../core/infiniteQueryObserver'\nimport { QueryFunction, QueryKey } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  options: UseInfiniteQueryOptions<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKey,\n  options?: UseInfiniteQueryOptions<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TQueryFnData>,\n  options?: UseInfiniteQueryOptions<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n  arg1: QueryKey | UseInfiniteQueryOptions<TQueryFnData, TError, TData>,\n  arg2?:\n    | QueryFunction<TQueryFnData>\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData>,\n  arg3?: UseInfiniteQueryOptions<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import React from 'react'\n\nimport { notifyManager } from '../core/notifyManager'\nimport { QueryKey } from '../core/types'\nimport { parseFilterArgs, QueryFilters } from '../core/utils'\nimport { useQueryClient } from './QueryClientProvider'\n\nexport function useIsFetching(filters?: QueryFilters): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters\n): number {\n  const mountedRef = React.useRef(false)\n\n  const queryClient = useQueryClient()\n\n  const [filters] = parseFilterArgs(arg1, arg2)\n  const [isFetching, setIsFetching] = React.useState(\n    queryClient.isFetching(filters)\n  )\n\n  const filtersRef = React.useRef(filters)\n  filtersRef.current = filters\n  const isFetchingRef = React.useRef(isFetching)\n  isFetchingRef.current = isFetching\n\n  React.useEffect(() => {\n    mountedRef.current = true\n\n    const unsubscribe = queryClient.getQueryCache().subscribe(\n      notifyManager.batchCalls(() => {\n        if (mountedRef.current) {\n          const newIsFetching = queryClient.isFetching(filtersRef.current)\n          if (isFetchingRef.current !== newIsFetching) {\n            setIsFetching(newIsFetching)\n          }\n        }\n      })\n    )\n\n    return () => {\n      mountedRef.current = false\n      unsubscribe()\n    }\n  }, [queryClient])\n\n  return isFetching\n}\n","import React from 'react'\n\nimport { notifyManager } from '../core/notifyManager'\nimport { noop, parseMutationArgs } from '../core/utils'\nimport { MutationObserver } from '../core/mutationObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { MutationFunction, MutationKey } from '../core/types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const mountedRef = React.useRef(false)\n  const [, forceUpdate] = React.useState(0)\n\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient()\n\n  const obsRef = React.useRef<MutationObserver<any, any, any, any>>()\n\n  if (!obsRef.current) {\n    obsRef.current = new MutationObserver(queryClient, options)\n  } else {\n    obsRef.current.setOptions(options)\n  }\n\n  const currentResult = obsRef.current.getCurrentResult()\n\n  React.useEffect(() => {\n    mountedRef.current = true\n\n    const unsubscribe = obsRef.current!.subscribe(\n      notifyManager.batchCalls(() => {\n        if (mountedRef.current) {\n          forceUpdate(x => x + 1)\n        }\n      })\n    )\n    return () => {\n      mountedRef.current = false\n      unsubscribe()\n    }\n  }, [])\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >((variables, mutateOptions) => {\n    obsRef.current!.mutate(variables, mutateOptions).catch(noop)\n  }, [])\n\n  if (currentResult.error && obsRef.current.options.useErrorBoundary) {\n    throw currentResult.error\n  }\n\n  return { ...currentResult, mutate, mutateAsync: currentResult.mutate }\n}\n","import React from 'react'\n\nimport { notifyManager } from '../core/notifyManager'\nimport { QueriesObserver } from '../core/queriesObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\n\nexport function useQueries(queries: UseQueryOptions[]): UseQueryResult[] {\n  const mountedRef = React.useRef(false)\n  const [, forceUpdate] = React.useState(0)\n\n  const queryClient = useQueryClient()\n\n  const defaultedQueries = queries.map(options => {\n    const defaultedOptions = queryClient.defaultQueryObserverOptions(options)\n\n    // Make sure the results are already in fetching state before subscribing or updating options\n    defaultedOptions.optimisticResults = true\n\n    return defaultedOptions\n  })\n\n  const obsRef = React.useRef<QueriesObserver>()\n\n  if (!obsRef.current) {\n    obsRef.current = new QueriesObserver(queryClient, defaultedQueries)\n  }\n\n  const result = obsRef.current.getOptimisticResult(defaultedQueries)\n\n  React.useEffect(() => {\n    mountedRef.current = true\n\n    const unsubscribe = obsRef.current!.subscribe(\n      notifyManager.batchCalls(() => {\n        if (mountedRef.current) {\n          forceUpdate(x => x + 1)\n        }\n      })\n    )\n\n    return () => {\n      mountedRef.current = false\n      unsubscribe()\n    }\n  }, [])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    obsRef.current!.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries])\n\n  return result\n}\n","import { QueryObserver } from '../core'\nimport { QueryFunction, QueryKey } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKey,\n  options?: UseQueryOptions<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TQueryFnData>,\n  options?: UseQueryOptions<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<TQueryFnData, TError, TData = TQueryFnData>(\n  arg1: QueryKey | UseQueryOptions<TQueryFnData, TError, TData>,\n  arg2?:\n    | QueryFunction<TQueryFnData>\n    | UseQueryOptions<TQueryFnData, TError, TData>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","Subscribable","listeners","subscribe","listener","callback","push","onSubscribe","_this","filter","x","onUnsubscribe","hasListeners","this","length","_extends","assign","target","i","arguments","source","key","hasOwnProperty","call","apply","isServer","window","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","ensureArray","Array","isArray","difference","array1","array2","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","isActive","active","exact","fetching","inactive","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isStale","isFetching","queryKeyHashFn","hashQueryKey","asArray","JSON","stringify","_","val","isPlainObject","keys","sort","reduce","result","a","b","partialDeepEqual","some","replaceEqualDeep","array","aSize","bItems","bSize","copy","equalItems","o","hasObjectPrototype","ctor","prot","toString","scheduleMicrotask","Promise","resolve","then","catch","error","setTimeout","focusManager","removeEventListener","setDefaultEventListener","setEventListener","setup","focused","setFocused","onFocus","forEach","isFocused","document","undefined","includes","visibilityState","_window","addEventListener","onlineManager","online","setOnline","onOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","isCancelable","cancel","CancelledError","revert","silent","isCancelledError","Retryer","config","cancelFn","continueFn","promiseResolve","promiseReject","cancelRetry","cancelOptions","continue","isPaused","isResolved","isTransportCancelable","promise","outerResolve","outerReject","onSuccess","reject","onError","run","promiseOrValue","fn","timeout","retry","delay","retryDelay","shouldRetry","onFail","continueResolve","onPause","onContinue","notifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","flush","schedule","batchCalls","args","_this2","_this3","setNotifyFunction","setBatchNotifyFunction","logger","console","warn","log","getLogger","Query","defaultOptions","setOptions","observers","cache","initialState","state","getDefaultState","scheduleGc","cacheTime","setDefaultOptions","clearGcTimeout","gcTimeout","optionalRemove","clearTimeout","remove","setData","prevData","data","isDataEqual","_this$options$isDataE","structuralSharing","dispatch","type","dataUpdatedAt","setState","retryer","destroy","reset","observer","enabled","isInvalidated","getCurrentResult","isStaleByTime","find","shouldFetchOnWindowFocus","refetch","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","cancelRefetch","queryFnContext","pageParam","context","fetchFn","behavior","_this$options$behavio","onFetch","revertState","fetchMeta","_context$fetchOptions","meta","_context$fetchOptions2","action","reducer","onQueryUpdate","initialData","initialDataUpdatedAt","hasData","dataUpdateCount","errorUpdateCount","errorUpdatedAt","fetchFailureCount","status","QueryCache","queries","queriesMap","build","client","get","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","_this4","_this5","Mutation","mutationId","mutationCache","execute","restored","variables","onMutate","executeMutation","onSettled","mutationFn","onMutationUpdate","MutationCache","mutations","mutation","defaultMutationOptions","mutationKey","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","fetchPage","manual","param","previous","queryFnResult","page","getNextPageParam","getPreviousPageParam","finalPromise","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","getQueryData","_this$queryCache$find","setQueryData","parsedOptions","defaultedOptions","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","map","all","invalidateQueries","refetchActive","refetchInactive","throwOnError","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","cancelMutations","_this6","getMutationCache","getQueryCache","getDefaultOptions","setQueryDefaults","_this$queryDefaults$f","setMutationDefaults","_this$mutationDefault","_defaulted","defaultQueryObserverOptions","QueryObserver","trackedProps","bindMethods","bind","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","refetchOnReconnect","refetchOnWindowFocus","clearTimers","notifyOptions","prevOptions","prevQuery","Error","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","refetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","trackedResult","defineProperty","configurable","enumerable","typedKey","getNextResult","unsubscribe","isError","getCurrentQuery","fetchOptimistic","clearStaleTimeout","staleTimeoutId","clearRefetchInterval","refetchIntervalId","setInterval","_this7","refetchIntervalInBackground","clearInterval","placeholderData","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectError","isLoading","isIdle","isFetched","isFetchedAfterMount","isLoadingError","isRefetchError","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsExclusions","includedProps","changed","isIncluded","isExcluded","shallowEqualObjects","defaultNotifyOptions","_this8","retryOnMount","shouldLoadOnMount","refetchOnMount","shouldRefetchOnMount","QueriesObserver","observersMap","setQueries","onUpdate","updateObservers","getObserver","hasIndexChange","prevObservers","prevOberversMap","newResult","newObservers","newObserversMap","index","slice","replaceAt","InfiniteQueryObserver","_QueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","MutationObserver","mutate","currentMutation","mutateOptions","defaultContext","React","createContext","getQueryClientContext","ReactQueryClientContext","useQueryClient","queryClient","useContext","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","useBaseQuery","Observer","mountedRef","useRef","forceUpdate","useState","errorResetBoundary","suspense","useErrorBoundary","obsRef","current","useEffect","children","Context","Provider","useMemo","newLogger","setIsFetching","filtersRef","isFetchingRef","newIsFetching","parseMutationArgs","useCallback","mutateAsync","defaultedQueries"],"mappings":"2OAAe,SAASA,EAAeC,EAAUC,GAC/CD,EAASE,UAAYC,OAAOC,OAAOH,EAAWC,WAC9CF,EAASE,UAAUG,YAAcL,EACjCA,EAASM,UAAYL,yECDVM,+BAIJC,UAAY,8BAGnBC,UAAA,SAAUC,cACFC,EAAWD,GAAa,yBAEzBF,UAAUI,KAAKD,QAEfE,cAEE,WACLC,EAAKN,UAAYM,EAAKN,UAAUO,QAAO,SAAAC,UAAKA,IAAML,KAClDG,EAAKG,oBAITC,aAAA,kBACSC,KAAKX,UAAUY,OAAS,KAGvBP,YAAV,eAIUI,cAAV,kBC9Ba,SAASI,WACtBA,EAAWlB,OAAOmB,QAAU,SAAUC,OAC/B,IAAIC,EAAI,EAAGA,EAAIC,UAAUL,OAAQI,IAAK,KACrCE,EAASD,UAAUD,OAElB,IAAIG,KAAOD,EACVvB,OAAOD,UAAU0B,eAAeC,KAAKH,EAAQC,KAC/CJ,EAAOI,GAAOD,EAAOC,WAKpBJ,IAGOO,MAAMX,KAAMM,WCoCvB,IAAMM,EAA6B,oBAAXC,OAExB,SAASC,KAIT,SAASC,EACdC,EACAC,SAE0B,mBAAZD,EACTA,EAAgDC,GACjDD,EAGC,SAASE,EAAeC,SACL,iBAAVA,GAAsBA,GAAS,GAAKA,IAAUC,EAAAA,EAGvD,SAASC,EAAeF,UACtBG,MAAMC,QAAQJ,GAASA,EAAQ,CAACA,GAGlC,SAASK,EAAcC,EAAaC,UAClCD,EAAO7B,QAAO,SAAAC,UAA4B,IAAvB6B,EAAOC,QAAQ9B,MASpC,SAAS+B,EAAeC,EAAmBC,UACzCC,KAAKC,IAAIH,GAAaC,GAAa,GAAKG,KAAKC,MAAO,GAGtD,SAASC,EACdC,EACAC,EACAC,UAEKC,EAAWH,GAII,mBAATC,OACGC,GAAME,SAAUJ,EAAMK,QAASJ,SAGjCA,GAAMG,SAAUJ,IAPnBA,EA+BJ,SAASM,EAIdN,EACAC,EACAC,UAEQC,EAAWH,GACf,MAAMC,GAAMG,SAAUJ,IAAQE,GAC9B,CAACF,GAAQ,GAAIC,GAGZ,SAASM,EACdC,EACAC,OAsBIC,EAnBFC,EAOEH,EAPFG,OACAC,EAMEJ,EANFI,MACAC,EAKEL,EALFK,SACAC,EAIEN,EAJFM,SACAC,EAGEP,EAHFO,UACAX,EAEEI,EAFFJ,SACAY,EACER,EADFQ,SAGEb,EAAWC,MACTQ,MACEH,EAAMQ,YAAcC,EAAsBd,EAAUK,EAAMU,gBACrD,OAEJ,IAAKC,EAAgBX,EAAML,SAAUA,UACnC,SAMM,IAAbU,GAAuBH,IAAWG,EACpCJ,GAAW,IACS,IAAXC,GAAqBG,IAAaH,KAC3CD,GAAW,IAGW,kBAAbA,GAA0BD,EAAMC,aAAeA,MAIrC,kBAAVM,GAAuBP,EAAMY,YAAcL,MAI9B,kBAAbH,GAA0BJ,EAAMa,eAAiBT,MAIxDE,IAAcA,EAAUN,MAOvB,SAASS,EACdd,EACAe,iBAEeA,SAAAA,EAASI,iBAAkBC,GAC5BpB,GAMT,SAASoB,EAAapB,OAQGrB,EAPxB0C,EAAUvC,MAAMC,QAAQiB,GAAYA,EAAW,CAACA,UAOxBrB,EANP0C,EAOhBC,KAAKC,UAAU5C,GAAO,SAAC6C,EAAGC,UAC/BC,EAAcD,GACVjF,OAAOmF,KAAKF,GACTG,OACAC,QAAO,SAACC,EAAQ9D,UACf8D,EAAO9D,GAAOyD,EAAIzD,GACX8D,IACN,IACLL,KAOD,SAAST,EACde,EACAC,UAQK,SAASC,EAAiBF,EAAQC,MACnCD,IAAMC,SACD,YAGED,UAAaC,SACf,KAGLD,GAAKC,GAAkB,iBAAND,GAA+B,iBAANC,SACpCxF,OAAOmF,KAAKK,GAAGE,MAAK,SAAAlE,UAAQiE,EAAiBF,EAAE/D,GAAMgE,EAAEhE,cAG1D,EAnBAiE,CAAiBpD,EAAYkD,GAAIlD,EAAYmD,IA4B/C,SAASG,EAAiBJ,EAAQC,MACnCD,IAAMC,SACDD,MAGHK,EAAQtD,MAAMC,QAAQgD,IAAMjD,MAAMC,QAAQiD,MAE5CI,GAAUV,EAAcK,IAAML,EAAcM,GAAK,SAC7CK,EAAQD,EAAQL,EAAEtE,OAASjB,OAAOmF,KAAKI,GAAGtE,OAC1C6E,EAASF,EAAQJ,EAAIxF,OAAOmF,KAAKK,GACjCO,EAAQD,EAAO7E,OACf+E,EAAYJ,EAAQ,GAAK,GAE3BK,EAAa,EAER5E,EAAI,EAAGA,EAAI0E,EAAO1E,IAAK,KACxBG,EAAMoE,EAAQvE,EAAIyE,EAAOzE,GAC/B2E,EAAKxE,GAAOmE,EAAiBJ,EAAE/D,GAAMgE,EAAEhE,IACnCwE,EAAKxE,KAAS+D,EAAE/D,IAClByE,WAIGJ,IAAUE,GAASE,IAAeJ,EAAQN,EAAIS,SAGhDR,EAqBF,SAASN,EAAcgB,OACvBC,EAAmBD,UACf,MAIHE,EAAOF,EAAEhG,oBACK,IAATkG,SACF,MAIHC,EAAOD,EAAKrG,kBACboG,EAAmBE,MAKnBA,EAAK5E,eAAe,iBAQ3B,SAAS0E,EAAmBD,SACmB,oBAAtClG,OAAOD,UAAUuG,SAAS5E,KAAKwE,GAGjC,SAAS3C,EAAWpB,SACD,iBAAVA,GAAsBG,MAAMC,QAAQJ,GAiB7C,SAASoE,EAAkB/F,GAChCgG,QAAQC,UACLC,KAAKlG,GACLmG,OAAM,SAAAC,UACLC,YAAW,iBACHD,YC1RDE,EAAe,oGAnEhBpG,YAAV,WACOM,KAAK+F,0BACHC,6BAITC,iBAAA,SACEC,cAEIlG,KAAK+F,0BACFA,2BAEFA,oBAAsBG,GAAM,SAACC,GACT,kBAAZA,EACTxG,EAAKyG,WAAWD,GAEhBxG,EAAK0G,gBAKXD,WAAA,SAAWD,QACJA,QAAUA,EAEXA,QACGE,aAITA,QAAA,gBACOhH,UAAUiH,SAAQ,SAAA/G,GACrBA,UAIJgH,UAAA,iBAC8B,kBAAjBvG,KAAKmG,QACPnG,KAAKmG,QAIU,oBAAbK,UAIJ,MAACC,EAAW,UAAW,aAAaC,SACzCF,SAASG,oBAILX,wBAAR,kBACOpF,aAAYC,eAAA+F,EAAQC,wBAClBZ,kBAAiB,SAAAI,UAEpBxF,OAAOgG,iBAAiB,mBAAoBR,GAAS,GACrDxF,OAAOgG,iBAAiB,QAASR,GAAS,GAEnC,WAELxF,OAAOkF,oBAAoB,mBAAoBM,GAC/CxF,OAAOkF,oBAAoB,QAASM,WAhEnBjH,ICuEd0H,EAAgB,oGAnEjBpH,YAAV,WACOM,KAAK+F,0BACHC,6BAITC,iBAAA,SACEC,cAEIlG,KAAK+F,0BACFA,2BAEFA,oBAAsBG,GAAM,SAACa,GACV,kBAAXA,EACTpH,EAAKqH,UAAUD,GAEfpH,EAAKsH,iBAKXD,UAAA,SAAUD,QACHA,OAASA,EAEVA,QACGE,cAITA,SAAA,gBACO5H,UAAUiH,SAAQ,SAAA/G,GACrBA,UAIJ2H,SAAA,iBAC6B,kBAAhBlH,KAAK+G,OACP/G,KAAK+G,OAIS,oBAAdI,gBACqB,IAArBA,UAAUC,QAKZD,UAAUC,UAGXpB,wBAAR,kBACOpF,aAAYC,eAAA+F,EAAQC,wBAClBZ,kBAAiB,SAAAgB,UAEpBpG,OAAOgG,iBAAiB,SAAUI,GAAU,GAC5CpG,OAAOgG,iBAAiB,UAAWI,GAAU,GAEtC,WAELpG,OAAOkF,oBAAoB,SAAUkB,GACrCpG,OAAOkF,oBAAoB,UAAWkB,WAhEpB7H,ICyB5B,SAASiI,EAAkBC,UAClBvF,KAAKwF,IAAI,aAAO,EAAKD,GAAc,KAOrC,SAASE,EAAarG,SACK,yBAAlBA,SAAAA,EAAOsG,YAQVC,EAGX,SAAYnE,QACLoE,aAASpE,SAAAA,EAASoE,YAClBC,aAASrE,SAAAA,EAASqE,QAIpB,SAASC,EAAiB1G,UACxBA,aAAiBuG,MAKbI,EAUX,SAAYC,OAENC,EACAC,EACAC,EACAC,SAJAC,GAAc,OAMbX,OAAS,SAAAY,gBAAiBL,SAAAA,EAAWK,SACrCD,YAAc,WACjBA,GAAc,QAEXE,SAAW,wBAAML,SAAAA,UACjBX,aAAe,OACfiB,UAAW,OACXC,YAAa,OACbC,uBAAwB,OACxBC,QAAU,IAAIlD,SAAe,SAACmD,EAAcC,GAC/CV,EAAiBS,EACjBR,EAAgBS,SAGZnD,EAAU,SAACtE,GACVxB,EAAK6I,aACR7I,EAAK6I,YAAa,QAClBT,EAAOc,WAAPd,EAAOc,UAAY1H,SACnB8G,GAAAA,IACAC,EAAe/G,KAIb2H,EAAS,SAAC3H,GACTxB,EAAK6I,aACR7I,EAAK6I,YAAa,QAClBT,EAAOgB,SAAPhB,EAAOgB,QAAU5H,SACjB8G,GAAAA,IACAE,EAAchH,MAiBN,SAAN6H,QAEArJ,EAAK6I,gBAILS,MAIFA,EAAiBlB,EAAOmB,KACxB,MAAOtD,GACPqD,EAAiBzD,QAAQsD,OAAOlD,GAIlCoC,EAAW,SAAAK,OACJ1I,EAAK6I,aACRM,EAAO,IAAIpB,EAAeW,IAGtBb,EAAayB,QAEbA,EAAexB,SACf,YAMR9H,EAAK8I,sBAAwBjB,EAAayB,GAE1CzD,QAAQC,QAAQwD,GACbvD,KAAKD,GACLE,OAAM,SAAAC,eAEDjG,EAAK6I,gBHuLGW,EGlLNC,WAAQrB,EAAOqB,SAAS,EAExBC,EAAQtI,WADKgH,EAAOuB,cAAcjC,EACG1H,EAAK2H,eAAiB,EAC3DiC,GACM,IAAVH,GACkB,iBAAVA,GAAsBzJ,EAAK2H,aAAe8B,GAChC,mBAAVA,GAAwBA,EAAMzJ,EAAK2H,aAAc1B,OAEvDwC,GAAgBmB,EAMpB5J,EAAK2H,qBAGLS,EAAOyB,QAAPzB,EAAOyB,OAAS7J,EAAK2H,aAAc1B,IHiKvBuD,EG9JNE,EH+JP,IAAI7D,SAAQ,SAAAC,GACjBI,WAAWJ,EAAS0D,OG9JXzD,MAAK,eACCI,EAAaS,cAAgBO,EAAcI,kBA5EjD,IAAI1B,SAAQ,SAAAiE,GACjBxB,EAAawB,EACb9J,EAAK4I,UAAW,QAChBR,EAAO2B,SAAP3B,EAAO2B,aACNhE,MAAK,WACNuC,OAAaxB,EACb9G,EAAK4I,UAAW,QAChBR,EAAO4B,YAAP5B,EAAO4B,mBAyEFjE,MAAK,WACA0C,EACFU,EAAOlD,GAEPoD,YArBJF,EAAOlD,QA4BfoD,IC1GSY,EAAgB,iCA5EpBC,MAAQ,QACRC,aAAe,OAEfC,SAAW,SAACvK,GACfA,UAGGwK,cAAgB,SAACxK,GACpBA,gCAIJyK,MAAA,SAASzK,QACFsK,mBACCxF,EAAS9E,gBACVsK,eACA9J,KAAK8J,mBACHI,QAEA5F,KAGT6F,SAAA,SAAS3K,cACHQ,KAAK8J,kBACFD,MAAMpK,KAAKD,GAEhB+F,GAAkB,WAChB5F,EAAKoK,SAASvK,SAQpB4K,WAAA,SAA+B5K,qBACrB,sCAAI6K,2BAAAA,kBACVC,EAAKH,UAAS,WACZ3K,eAAY6K,UAKlBH,MAAA,sBACQL,EAAQ7J,KAAK6J,WACdA,MAAQ,GACTA,EAAM5J,QACRsF,GAAkB,WAChBgF,EAAKP,eAAc,WACjBH,EAAMvD,SAAQ,SAAA9G,GACZ+K,EAAKR,SAASvK,eAWxBgL,kBAAA,SAAkBtB,QACXa,SAAWb,KAOlBuB,uBAAA,SAAuBvB,QAChBc,cAAgBd,SC3ErBwB,EAAiBC,SAAW,CAC9B/E,MAAO9E,EACP8J,KAAM9J,EACN+J,IAAK/J,GAGA,SAASgK,WACPJ,MCqGIK,wBAoBChD,QACLiD,eAAiBjD,EAAOiD,oBACxBC,WAAWlD,EAAOxE,cAClB2H,UAAY,QACZC,MAAQpD,EAAOoD,WACf3I,SAAWuF,EAAOvF,cAClBa,UAAY0E,EAAO1E,eACnB+H,aAAerD,EAAOsD,OAASrL,KAAKsL,gBAAgBtL,KAAKuD,cACzD8H,MAAQrL,KAAKoL,kBACbG,wCAGCN,WAAR,SACE1H,cAEKA,aAAevD,KAAKgL,eAAmBzH,QAGvCiI,UAAYzJ,KAAKC,IACpBhC,KAAKwL,WAAa,WAClBxL,KAAKuD,QAAQiI,aAAa,QAI9BC,kBAAA,SAAkBlI,QACXyH,eAAiBzH,KAGhBgI,WAAR,2BACOG,iBAEDxK,EAAelB,KAAKwL,kBACjBG,UAAY9F,YAAW,WAC1BlG,EAAKiM,mBACJ5L,KAAKwL,eAIJE,eAAR,WACEG,aAAa7L,KAAK2L,gBACbA,eAAYlF,KAGXmF,eAAR,WACO5L,KAAKkL,UAAUjL,QAAWD,KAAKqL,MAAM3H,iBACnCyH,MAAMW,OAAO9L,SAItB+L,QAAA,SACE/K,EACAuC,WAEMyI,EAAWhM,KAAKqL,MAAMY,KAGxBA,EAAOlL,EAAiBC,EAASgL,2BAG5BzI,SAAQ2I,oBAAbC,SAA2BH,EAAUC,IACvCA,EAAOD,GACqC,IAAnChM,KAAKuD,QAAQ6I,oBAEtBH,EAAOtH,EAAiBqH,EAAUC,SAI/BI,SAAS,CACZJ,KAAAA,EACAK,KAAM,UACNC,oBAAehJ,SAAAA,EAAS1B,YAGnBoK,KAGTO,SAAA,SAASnB,QACFgB,SAAS,CAAEC,KAAM,WAAYjB,MAAAA,OAGpC5D,OAAA,SAAOlE,SACCmF,EAAU1I,KAAK0I,6BAChB+D,YAAShF,OAAOlE,GACdmF,EAAUA,EAAQhD,KAAK5E,GAAM6E,MAAM7E,GAAQ0E,QAAQC,aAG5DiH,QAAA,gBACOhB,sBACAjE,OAAO,CAAEG,QAAQ,OAGxB+E,MAAA,gBACOD,eACAF,SAASxM,KAAKoL,iBAGrBtI,SAAA,kBACS9C,KAAKkL,UAAUxG,MAAK,SAAAkI,UAAyC,IAA7BA,EAASrJ,QAAQsJ,cAG1DnJ,WAAA,kBACS1D,KAAKqL,MAAM3H,cAGpBD,QAAA,kBAEIzD,KAAKqL,MAAMyB,gBACV9M,KAAKqL,MAAMkB,eACZvM,KAAKkL,UAAUxG,MAAK,SAAAkI,UAAYA,EAASG,mBAAmBtJ,cAIhEuJ,cAAA,SAAclL,mBAAAA,IAAAA,EAAY,GAEtB9B,KAAKqL,MAAMyB,gBACV9M,KAAKqL,MAAMkB,gBACX3K,EAAe5B,KAAKqL,MAAMkB,cAAezK,MAI9CuE,QAAA,iBACQuG,EAAW5M,KAAKkL,UAAU+B,MAAK,SAAApN,UAAKA,EAAEqN,8BAExCN,GACFA,EAASO,wBAINV,YAASnE,cAGhBrB,SAAA,iBACQ2F,EAAW5M,KAAKkL,UAAU+B,MAAK,SAAApN,UAAKA,EAAEuN,4BAExCR,GACFA,EAASO,wBAINV,YAASnE,cAGhB+E,YAAA,SAAYT,IACgC,IAAtC5M,KAAKkL,UAAUvJ,QAAQiL,UACpB1B,UAAUzL,KAAKmN,QAGflB,sBAEAP,MAAMmC,OAAOtN,UAItBuN,eAAA,SAAeX,IAC6B,IAAtC5M,KAAKkL,UAAUvJ,QAAQiL,UACpB1B,UAAYlL,KAAKkL,UAAUtL,QAAO,SAAAC,UAAKA,IAAM+M,KAE7C5M,KAAKkL,UAAUjL,SAGdD,KAAKyM,UACHzM,KAAKyM,QAAQhE,2BACVgE,QAAQhF,OAAO,CAAEE,QAAQ,SAEzB8E,QAAQrE,eAIbpI,KAAKwL,eACFD,kBAEAJ,MAAMW,OAAO9L,YAIjBmL,MAAMmC,OAAOtN,UAItBwN,WAAA,WACOxN,KAAKqL,MAAMyB,oBACTT,SAAS,CAAEC,KAAM,kBAI1BmB,MAAA,SACElK,EACAmK,qBAEI1N,KAAKqL,MAAM3H,cACT1D,KAAKqL,MAAMkB,sBAAiBmB,SAAAA,EAAcC,oBAEvClG,OAAO,CAAEG,QAAQ,SACjB,GAAI5H,KAAK0I,eAEP1I,KAAK0I,WAKZnF,QACG0H,WAAW1H,IAKbvD,KAAKuD,QAAQd,QAAS,KACnBmK,EAAW5M,KAAKkL,UAAU+B,MAAK,SAAApN,UAAKA,EAAE0D,QAAQd,WAChDmK,QACG3B,WAAW2B,EAASrJ,iBAKvBf,EAAWnB,EAAYrB,KAAKwC,UAC5BoL,EAAuC,CAC3CpL,SAAAA,EACAqL,eAAWpH,GAUPqH,EAAqD,CACzDJ,aAAAA,EACAnK,QAASvD,KAAKuD,QACdf,SAAAA,EACA6I,MAAOrL,KAAKqL,MACZ0C,QAXc,kBACdzD,EAAK/G,QAAQd,QACT6H,EAAK/G,QAAQd,QAAQmL,GACrBpI,QAAQsD,OAAO,+BAWjB9I,KAAKuD,QAAQyK,iBAAbC,EAAuBC,yBACpB3K,QAAQyK,aAAUE,QAAQJ,UAI5BK,YAAcnO,KAAKqL,MAIrBrL,KAAKqL,MAAM3H,YACZ1D,KAAKqL,MAAM+C,sBAAcN,EAAQJ,qBAARW,EAAsBC,aAE1CjC,SAAS,CAAEC,KAAM,QAASgC,cAAMR,EAAQJ,qBAARa,EAAsBD,mBAIxD7B,QAAU,IAAI3E,EAAQ,CACzBoB,GAAI4E,EAAQC,QACZlF,UAAW,SAAAoD,GACT3B,EAAKyB,QAAQE,GAGU,IAAnB3B,EAAKkB,WACPlB,EAAKsB,kBAGT7C,QAAS,SAAAnD,GAEDiC,EAAiBjC,IAAUA,EAAMgC,QACrC0C,EAAK+B,SAAS,CACZC,KAAM,QACN1G,MAAOA,IAINiC,EAAiBjC,KAEhB0E,EAAKa,MAAMpD,OAAOgB,SACpBuB,EAAKa,MAAMpD,OAAOgB,QAAQnD,EAAO0E,GAInCQ,IAAYlF,MAAMA,IAIG,IAAnB0E,EAAKkB,WACPlB,EAAKsB,kBAGTpC,OAAQ,WACNc,EAAK+B,SAAS,CAAEC,KAAM,YAExB5C,QAAS,WACPY,EAAK+B,SAAS,CAAEC,KAAM,WAExB3C,WAAY,WACVW,EAAK+B,SAAS,CAAEC,KAAM,cAExBlD,MAAO0E,EAAQvK,QAAQ6F,MACvBE,WAAYwE,EAAQvK,QAAQ+F,kBAGzBZ,QAAU1I,KAAKyM,QAAQ/D,QAErB1I,KAAK0I,WAGN2D,SAAR,SAAiBmC,mBACVnD,MAAQrL,KAAKyO,QAAQzO,KAAKqL,MAAOmD,GAEtC5E,EAAcK,OAAM,WAClBM,EAAKW,UAAU5E,SAAQ,SAAAsG,GACrBA,EAAS8B,cAAcF,MAGzBjE,EAAKY,MAAMmC,OAAO/C,SAIZe,gBAAV,SACE/H,OAEM0I,EAC2B,mBAAxB1I,EAAQoL,YACVpL,EAAQoL,cACTpL,EAAQoL,YAIRC,OAFgD,IAAxBrL,EAAQoL,YAGM,mBAAjCpL,EAAQqL,qBACZrL,EAAQqL,uBACTrL,EAAQqL,qBACV,EAEEC,OAA0B,IAAT5C,QAEhB,CACLA,KAAAA,EACA6C,gBAAiB,EACjBvC,cAAesC,QAAUD,EAAAA,EAAwB3M,KAAKC,MAAQ,EAC9D0D,MAAO,KACPmJ,iBAAkB,EAClBC,eAAgB,EAChBC,kBAAmB,EACnBb,UAAW,KACX1K,YAAY,EACZoJ,eAAe,EACfvE,UAAU,EACV2G,OAAQL,EAAU,UAAY,WAIxBJ,QAAV,SACEpD,EACAmD,kBAEQA,EAAOlC,UACR,qBAEEjB,GACH4D,kBAAmB5D,EAAM4D,kBAAoB,QAE5C,oBAEE5D,GACH9C,UAAU,QAET,uBAEE8C,GACH9C,UAAU,QAET,oBAEE8C,GACH4D,kBAAmB,EACnBb,mBAAWI,EAAOF,QAAQ,KAC1B5K,YAAY,EACZ6E,UAAU,EACV2G,OAAS7D,EAAMkB,cAA4BlB,EAAM6D,OAAlB,gBAE9B,sBAEE7D,GACHY,KAAMuC,EAAOvC,KACb6C,gBAAiBzD,EAAMyD,gBAAkB,EACzCvC,uBAAeiC,EAAOjC,iBAAiBtK,KAAKC,MAC5C0D,MAAO,KACPqJ,kBAAmB,EACnBvL,YAAY,EACZoJ,eAAe,EACfvE,UAAU,EACV2G,OAAQ,gBAEP,YACGtJ,EAAQ4I,EAAO5I,aAEjBiC,EAAiBjC,IAAUA,EAAM+B,QAAU3H,KAAKmO,iBACtCnO,KAAKmO,kBAId9C,GACHzF,MAAOA,EACPmJ,iBAAkB1D,EAAM0D,iBAAmB,EAC3CC,eAAgB/M,KAAKC,MACrB+M,kBAAmB5D,EAAM4D,kBAAoB,EAC7CvL,YAAY,EACZ6E,UAAU,EACV2G,OAAQ,cAEP,yBAEE7D,GACHyB,eAAe,QAEd,uBAEEzB,EACAmD,EAAOnD,sBAGLA,SCvhBF8D,yBAMCpH,sCAELA,OAASA,GAAU,KACnBqH,QAAU,KACVC,WAAa,uCAGpBC,MAAA,SACEC,EACAhM,EACA8H,SAEM7I,EAAWe,EAAQf,SACnBa,WACJE,EAAQF,aAAaC,EAAsBd,EAAUe,GACnDV,EAAQ7C,KAAKwP,IAAiCnM,UAE7CR,IACHA,EAAQ,IAAIkI,EAAM,CAChBI,MAAOnL,KACPwC,SAAAA,EACAa,UAAAA,EACAE,QAASgM,EAAOE,oBAAoBlM,GACpC8H,MAAAA,EACAL,eAAgBuE,EAAOG,iBAAiBlN,UAErCmN,IAAI9M,IAGJA,KAGT8M,IAAA,SAAI9M,GACG7C,KAAKqP,WAAWxM,EAAMQ,kBACpBgM,WAAWxM,EAAMQ,WAAaR,OAC9BuM,QAAQ3P,KAAKoD,QACbyK,OAAOzK,OAIhBiJ,OAAA,SAAOjJ,OACC+M,EAAa5P,KAAKqP,WAAWxM,EAAMQ,WAErCuM,IACF/M,EAAM6J,eAED0C,QAAUpP,KAAKoP,QAAQxP,QAAO,SAAAC,UAAKA,IAAMgD,KAE1C+M,IAAe/M,UACV7C,KAAKqP,WAAWxM,EAAMQ,gBAG1BiK,OAAOzK,OAIhBgN,MAAA,sBACEjG,EAAcK,OAAM,WAClBK,EAAK8E,QAAQ9I,SAAQ,SAAAzD,GACnByH,EAAKwB,OAAOjJ,YAKlB2M,IAAA,SACEnM,UAEOrD,KAAKqP,WAAWhM,MAGzByM,OAAA,kBACS9P,KAAKoP,WAGdnC,KAAA,SACE7K,EACAC,OAEOO,EAAWF,EAAgBN,EAAMC,kBAEX,IAAlBO,EAAQI,QACjBJ,EAAQI,OAAQ,GAGXhD,KAAKoP,QAAQnC,MAAK,SAAApK,UAASF,EAAWC,EAASC,SAMxDkN,QAAA,SAAQ3N,EAAgCC,OAC/BO,EAAWF,EAAgBN,EAAMC,aACjCO,EACH5C,KAAKoP,QAAQxP,QAAO,SAAAiD,UAASF,EAAWC,EAASC,MACjD7C,KAAKoP,WAGX9B,OAAA,SAAOzK,cACL+G,EAAcK,OAAM,WAClBM,EAAKlL,UAAUiH,SAAQ,SAAA/G,GACrBA,EAASsD,YAKfwD,QAAA,sBACEuD,EAAcK,OAAM,WAClB+F,EAAKZ,QAAQ9I,SAAQ,SAAAzD,GACnBA,EAAMwD,mBAKZY,SAAA,sBACE2C,EAAcK,OAAM,WAClBgG,EAAKb,QAAQ9I,SAAQ,SAAAzD,GACnBA,EAAMoE,qBA1HkB7H,GCmDnB8Q,wBAcCnI,QACLxE,aACAwE,EAAOiD,eACPjD,EAAOxE,cAEP4M,WAAapI,EAAOoI,gBACpBC,cAAgBrI,EAAOqI,mBACvBlF,UAAY,QACZG,MAAQtD,EAAOsD,OAASC,+BAG/BkB,SAAA,SAASnB,QACFgB,SAAS,CAAEC,KAAM,WAAYjB,MAAAA,OAGpCgC,YAAA,SAAYT,IACgC,IAAtC5M,KAAKkL,UAAUvJ,QAAQiL,SACpB1B,UAAUzL,KAAKmN,MAIxBW,eAAA,SAAeX,QACR1B,UAAYlL,KAAKkL,UAAUtL,QAAO,SAAAC,UAAKA,IAAM+M,QAGpDnF,OAAA,kBACMzH,KAAKyM,cACFA,QAAQhF,SACNzH,KAAKyM,QAAQ/D,QAAQhD,KAAK5E,GAAM6E,MAAM7E,IAExC0E,QAAQC,aAGjB6C,SAAA,kBACMtI,KAAKyM,cACFA,QAAQnE,WACNtI,KAAKyM,QAAQ/D,SAEf1I,KAAKqQ,aAGdA,QAAA,eACMpE,SAEEqE,EAAiC,YAAtBtQ,KAAKqL,MAAM6D,OAExBxG,EAAUlD,QAAQC,iBAEjB6K,SACEjE,SAAS,CAAEC,KAAM,UAAWiE,UAAWvQ,KAAKuD,QAAQgN,YACzD7H,EAAUA,EACPhD,MAAK,wBAAM/F,EAAK4D,QAAQiN,gBAAb7Q,EAAK4D,QAAQiN,SAAW7Q,EAAK0L,MAAMkF,cAC9C7K,MAAK,SAAAoI,GACAA,IAAYnO,EAAK0L,MAAMyC,SACzBnO,EAAK0M,SAAS,CACZC,KAAM,UACNwB,QAAAA,EACAyC,UAAW5Q,EAAK0L,MAAMkF,gBAMzB7H,EACJhD,MAAK,kBAAM/F,EAAK8Q,qBAChB/K,MAAK,SAAApB,GACJ2H,EAAO3H,KAERoB,MAAK,wBACJ/F,EAAK4D,QAAQsF,iBAAblJ,EAAK4D,QAAQsF,UACXoD,EACAtM,EAAK0L,MAAMkF,UACX5Q,EAAK0L,MAAMyC,YAGdpI,MAAK,wBACJ/F,EAAK4D,QAAQmN,iBAAb/Q,EAAK4D,QAAQmN,UACXzE,EACA,KACAtM,EAAK0L,MAAMkF,UACX5Q,EAAK0L,MAAMyC,YAGdpI,MAAK,kBACJ/F,EAAK0M,SAAS,CAAEC,KAAM,UAAWL,KAAAA,IAC1BA,KAERtG,OAAM,SAAAC,UAEDjG,EAAKyQ,cAAcrI,OAAOgB,SAC5BpJ,EAAKyQ,cAAcrI,OAAOgB,QACxBnD,EACAjG,EAAK0L,MAAMkF,UACX5Q,EAAK0L,MAAMyC,QACXnO,GAKJmL,IAAYlF,MAAMA,GAEXJ,QAAQC,UACZC,MAAK,wBACJ/F,EAAK4D,QAAQwF,eAAbpJ,EAAK4D,QAAQwF,QACXnD,EACAjG,EAAK0L,MAAMkF,UACX5Q,EAAK0L,MAAMyC,YAGdpI,MAAK,wBACJ/F,EAAK4D,QAAQmN,iBAAb/Q,EAAK4D,QAAQmN,eACXjK,EACAb,EACAjG,EAAK0L,MAAMkF,UACX5Q,EAAK0L,MAAMyC,YAGdpI,MAAK,iBACJ/F,EAAK0M,SAAS,CAAEC,KAAM,QAAS1G,MAAAA,IACzBA,WAKR6K,gBAAR,oCACOhE,QAAU,IAAI3E,EAAQ,CACzBoB,GAAI,kBACGoB,EAAK/G,QAAQoN,WAGXrG,EAAK/G,QAAQoN,WAAWrG,EAAKe,MAAMkF,WAFjC/K,QAAQsD,OAAO,wBAI1BU,OAAQ,WACNc,EAAK+B,SAAS,CAAEC,KAAM,YAExB5C,QAAS,WACPY,EAAK+B,SAAS,CAAEC,KAAM,WAExB3C,WAAY,WACVW,EAAK+B,SAAS,CAAEC,KAAM,cAExBlD,eAAOpJ,KAAKuD,QAAQ6F,SAAS,EAC7BE,WAAYtJ,KAAKuD,QAAQ+F,aAGpBtJ,KAAKyM,QAAQ/D,WAGd2D,SAAR,SAAiBmC,mBACVnD,MA4BT,SACEA,EACAmD,UAEQA,EAAOlC,UACR,qBAEEjB,GACH/D,aAAc+D,EAAM/D,aAAe,QAElC,oBAEE+D,GACH9C,UAAU,QAET,uBAEE8C,GACH9C,UAAU,QAET,sBAEE8C,GACHyC,QAASU,EAAOV,QAChB7B,UAAMxF,EACNb,MAAO,KACP2C,UAAU,EACV2G,OAAQ,UACRqB,UAAW/B,EAAO+B,gBAEjB,sBAEElF,GACHY,KAAMuC,EAAOvC,KACbrG,MAAO,KACPsJ,OAAQ,UACR3G,UAAU,QAET,oBAEE8C,GACHY,UAAMxF,EACNb,MAAO4I,EAAO5I,MACd0B,aAAc+D,EAAM/D,aAAe,EACnCiB,UAAU,EACV2G,OAAQ,cAEP,uBAEE7D,EACAmD,EAAOnD,sBAGLA,GAjFIoD,CAAQzO,KAAKqL,MAAOmD,GAEjC5E,EAAcK,OAAM,WAClBM,EAAKW,UAAU5E,SAAQ,SAAAsG,GACrBA,EAASgE,iBAAiBpC,MAE5BjE,EAAK6F,cAAc9C,OAAO/C,YAKzB,SAASe,UAMP,CACLwC,aAASrH,EACTwF,UAAMxF,EACNb,MAAO,KACP0B,aAAc,EACdiB,UAAU,EACV2G,OAAQ,OACRqB,eAAW9J,OClPFoK,yBAMC9I,sCAELA,OAASA,GAAU,KACnB+I,UAAY,KACZX,WAAa,sCAGpBb,MAAA,SACEC,EACAhM,EACA8H,OAEM0F,EAAW,IAAIb,EAAS,CAC5BE,cAAepQ,KACfmQ,aAAcnQ,KAAKmQ,WACnB5M,QAASgM,EAAOyB,uBAAuBzN,GACvC8H,MAAAA,EACAL,eAAgBzH,EAAQ0N,YACpB1B,EAAO2B,oBAAoB3N,EAAQ0N,kBACnCxK,gBAGDkJ,IAAIoB,GAEFA,KAGTpB,IAAA,SAAIoB,QACGD,UAAUrR,KAAKsR,QACfzD,OAAOyD,MAGdjF,OAAA,SAAOiF,QACAD,UAAY9Q,KAAK8Q,UAAUlR,QAAO,SAAAC,UAAKA,IAAMkR,KAClDA,EAAStJ,cACJ6F,OAAOyD,MAGdlB,MAAA,sBACEjG,EAAcK,OAAM,WAClBK,EAAKwG,UAAUxK,SAAQ,SAAAyK,GACrBzG,EAAKwB,OAAOiF,YAKlBjB,OAAA,kBACS9P,KAAK8Q,aAGdxD,OAAA,SAAOyD,cACLnH,EAAcK,OAAM,WAClBM,EAAKlL,UAAUiH,SAAQ,SAAA/G,GACrBA,EAASwR,YAKf1K,QAAA,gBACO8K,2BAGPlK,SAAA,gBACOkK,2BAGPA,sBAAA,eACQC,EAAkBpR,KAAK8Q,UAAUlR,QAAO,SAAAC,UAAKA,EAAEwL,MAAM9C,mBACpDqB,EAAcK,OAAM,kBACzBmH,EAAgB/M,QACd,SAACqE,EAASqI,UACRrI,EAAQhD,MAAK,kBAAMqL,EAASzI,WAAW3C,MAAM7E,QAC/C0E,QAAQC,kBA9EmBrG,GClB5B,SAASiS,UAKP,CACLnD,QAAS,SAAAJ,GACPA,EAAQC,QAAU,uBAmDZrF,EAlDE4I,WAAYxD,EAAQJ,wBAARW,EAAsBC,aAAtBC,EAA4B+C,UACxCzD,QAAYyD,SAAAA,EAAWzD,UACvB0D,EAA8C,mBAAzBD,SAAAA,EAAWE,WAChCC,EAAkD,oBAAzBH,SAAAA,EAAWE,WACpCE,YAAW5D,EAAQzC,MAAMY,eAAM0F,QAAS,GACxCC,YAAgB9D,EAAQzC,MAAMY,eAAM4F,aAAc,GACpDC,EAAgBF,EAChBG,GAAY,EAGVtP,EACJqL,EAAQvK,QAAQd,SAAY,kBAAM+C,QAAQsD,OAAO,oBAG7CkJ,EAAY,SAChBL,EACAM,EACAC,EACAC,MAEIJ,SACKvM,QAAQsD,OAAO,qBAGH,IAAVoJ,IAA0BD,GAAUN,EAAM1R,cAC5CuF,QAAQC,QAAQkM,OAGnB/D,EAAuC,CAC3CpL,SAAUsL,EAAQtL,SAClBqL,UAAWqE,GAGPE,EAAgB3P,EAAQmL,GAExBlF,EAAUlD,QAAQC,QAAQ2M,GAAe1M,MAAK,SAAA2M,UAClDP,EAAgBK,GACXD,UAAUJ,aACPA,GAAeI,IAChBC,GAAYE,UAASV,aAAaA,GAAOU,OAG9C7K,EAAa4K,KACM1J,EACRjB,OAAS2K,EAAc3K,eAG/BiB,MAMJgJ,EAASzR,OAKT,GAAIsR,EAAoB,KACrBU,OAA8B,IAAdpE,EAChBqE,EAAQD,EACVpE,EACAyE,EAAiBxE,EAAQvK,QAASmO,GACtChJ,EAAUsJ,EAAUN,EAAUO,EAAQC,QAInC,GAAIT,EAAwB,KACzBQ,OAA8B,IAAdpE,EAChBqE,EAAQD,EACVpE,EACA0E,EAAqBzE,EAAQvK,QAASmO,GAC1ChJ,EAAUsJ,EAAUN,EAAUO,EAAQC,GAAO,mBAK7CJ,EAAgB,OAEVG,OAAqD,IAArCnE,EAAQvK,QAAQ+O,iBAGtC5J,EAAUsJ,EAAU,GAAIC,EAAQL,EAAc,uBAGrCvR,GACPqI,EAAUA,EAAQhD,MAAK,SAAAiM,OACfO,EAAQD,EACVL,EAAcvR,GACdiS,EAAiBxE,EAAQvK,QAASoO,UAC/BK,EAAUL,EAAOM,EAAQC,OAL3B7R,EAAI,EAAGA,EAAIqR,EAASzR,OAAQI,MAA5BA,WA/BTqI,EAAUsJ,EAAU,QAyChBQ,EAAe9J,EAAQhD,MAAK,SAAAiM,SAAU,CAC1CA,MAAAA,EACAE,WAAYC,aAGYU,EAER/K,OAAS,WACzBsK,GAAY,EACRvK,EAAakB,IACfA,EAAQjB,UAIL+K,KAMR,SAASF,EACd/O,EACAoO,gBAEOpO,EAAQ+O,wBAAR/O,EAAQ+O,iBAAmBX,EAAMA,EAAM1R,OAAS,GAAI0R,GAGtD,SAASY,EACdhP,EACAoO,gBAEOpO,EAAQgP,4BAARhP,EAAQgP,qBAAuBZ,EAAM,GAAIA,GAO3C,SAASc,EACdlP,EACAoO,MAEIpO,EAAQ+O,kBAAoBhR,MAAMC,QAAQoQ,GAAQ,KAC9Ce,EAAgBJ,EAAiB/O,EAASoO,UAE9C,MAAOe,IAEW,IAAlBA,GASC,SAASC,EACdpP,EACAoO,MAEIpO,EAAQgP,sBAAwBjR,MAAMC,QAAQoQ,GAAQ,KAClDiB,EAAoBL,EAAqBhP,EAASoO,UAEtD,MAAOiB,IAEe,IAAtBA,OCpHOC,wBASC9K,YAAAA,IAAAA,EAA4B,SACjC+K,WAAa/K,EAAO+K,YAAc,IAAI3D,OACtCiB,cAAgBrI,EAAOqI,eAAiB,IAAIS,OAC5C7F,eAAiBjD,EAAOiD,gBAAkB,QAC1C+H,cAAgB,QAChBC,iBAAmB,8BAG1BC,MAAA,2BACOC,iBAAmBpN,EAAaxG,WAAU,WACzCwG,EAAaS,aAAeO,EAAcI,aAC5CvH,EAAKyQ,cAAc/J,UACnB1G,EAAKmT,WAAWzM,mBAGf8M,kBAAoBrM,EAAcxH,WAAU,WAC3CwG,EAAaS,aAAeO,EAAcI,aAC5CvH,EAAKyQ,cAAcnJ,WACnBtH,EAAKmT,WAAW7L,kBAKtBmM,QAAA,iCACOF,8CACAC,oCAKPzP,WAAA,SAAWtB,EAAgCC,OAClCO,EAAWF,EAAgBN,EAAMC,aACxCO,EAAQK,UAAW,EACZjD,KAAK8S,WAAW/C,QAAQnN,GAAS3C,UAG1CoT,aAAA,SACE7Q,EACAI,yBAEO5C,KAAK8S,WAAW7F,KAAYzK,EAAUI,WAAtC0Q,EAAgDjI,MAAMY,QAG/DsH,aAAA,SACE/Q,EACAxB,EACAuC,OAEMiQ,EAAgBrR,EAAeK,GAC/BiR,EAAmBzT,KAAKyP,oBAAoB+D,UAC3CxT,KAAK8S,WACTxD,MAAMtP,KAAMyT,GACZ1H,QAAQ/K,EAASuC,MAGtBmQ,cAAA,SACElR,EACAI,yBAEO5C,KAAK8S,WAAW7F,KAAoBzK,EAAUI,WAA9C+Q,EAAwDtI,SAKjEuI,cAAA,SAAcxR,EAAgCC,OACrCO,EAAWF,EAAgBN,EAAMC,MAClCyQ,EAAa9S,KAAK8S,WACxBlJ,EAAcK,OAAM,WAClB6I,EAAW/C,QAAQnN,GAAS0D,SAAQ,SAAAzD,GAClCiQ,EAAWhH,OAAOjJ,YAWxBgR,aAAA,SACEzR,EACAC,EACAC,gBAE2BI,EAAgBN,EAAMC,EAAMC,GAAhDM,OAASW,OACVuP,EAAa9S,KAAK8S,WAElBgB,OACDlR,GACHG,QAAQ,WAGH6G,EAAcK,OAAM,kBACzB6I,EAAW/C,QAAQnN,GAAS0D,SAAQ,SAAAzD,GAClCA,EAAM8J,WAEDrC,EAAKyJ,eAAeD,EAAgBvQ,SAU/CyQ,cAAA,SACE5R,EACAC,EACAC,gBAEsCI,EAAgBN,EAAMC,EAAMC,GAA3DM,cAASyF,aAAgB,UAEI,IAAzBA,EAAcV,SACvBU,EAAcV,QAAS,OAGnBsM,EAAWrK,EAAcK,OAAM,kBACnCM,EAAKuI,WAAW/C,QAAQnN,GAASsR,KAAI,SAAArR,UAASA,EAAM4E,OAAOY,gBAGtD7C,QAAQ2O,IAAIF,GAAUvO,KAAK5E,GAAM6E,MAAM7E,MAYhDsT,kBAAA,SACEhS,EACAC,EACAC,oBAE2BI,EAAgBN,EAAMC,EAAMC,GAAhDM,OAASW,OAEVuQ,OACDlR,GACHG,gBAAQH,EAAQyR,kBAChBnR,kBAAUN,EAAQ0R,6BAGb1K,EAAcK,OAAM,kBACzB+F,EAAK8C,WAAW/C,QAAQnN,GAAS0D,SAAQ,SAAAzD,GACvCA,EAAM2K,gBAEDwC,EAAK+D,eAAeD,EAAgBvQ,SAa/CwQ,eAAA,SACE3R,EACAC,EACAC,gBAE2BI,EAAgBN,EAAMC,EAAMC,GAAhDM,OAASW,OAEV0Q,EAAWrK,EAAcK,OAAM,kBACnCgG,EAAK6C,WAAW/C,QAAQnN,GAASsR,KAAI,SAAArR,UAASA,EAAM4K,cAGlD/E,EAAUlD,QAAQ2O,IAAIF,GAAUvO,KAAK5E,gBAEpCyC,SAAAA,EAASgR,gBACZ7L,EAAUA,EAAQ/C,MAAM7E,IAGnB4H,KAeT8L,WAAA,SACEpS,EACAC,EAGAC,OAEMkR,EAAgBrR,EAAeC,EAAMC,EAAMC,GAC3CmR,EAAmBzT,KAAKyP,oBAAoB+D,QAGZ,IAA3BC,EAAiBrK,QAC1BqK,EAAiBrK,OAAQ,OAGrBvG,EAAQ7C,KAAK8S,WAAWxD,MAAMtP,KAAMyT,UAEnC5Q,EAAMmK,cAAcyG,EAAiB3R,WACxCe,EAAM4K,MAAMgG,GACZjO,QAAQC,QAAQ5C,EAAMwI,MAAMY,SAUlCwI,cAAA,SACErS,EACAC,EACAC,UAEOtC,KAAKwU,WAAWpS,EAAaC,EAAaC,GAC9CoD,KAAK5E,GACL6E,MAAM7E,MA2BX4T,mBAAA,SACEtS,EACAC,EAGAC,OAEMkR,EAAgBrR,EAAeC,EAAMC,EAAMC,UACjDkR,EAAcxF,SAAWqD,IAKlBrR,KAAKwU,WAAWhB,MAazBmB,sBAAA,SACEvS,EACAC,EACAC,UAEOtC,KAAK0U,mBAAmBtS,EAAaC,EAAaC,GACtDoD,KAAK5E,GACL6E,MAAM7E,MAGX8T,gBAAA,sBACQX,EAAWrK,EAAcK,OAAM,kBACnC4K,EAAKzE,cAAcN,SAASoE,KAAI,SAAAnD,UAAYA,EAAStJ,sBAEhDjC,QAAQ2O,IAAIF,GAAUvO,KAAK5E,GAAM6E,MAAM7E,MAGhDqQ,sBAAA,kBACSnR,KAAK8U,mBAAmB3D,2BAGjCV,gBAAA,SAMElN,UAEOvD,KAAKoQ,cAAcd,MAAMtP,KAAMuD,GAAS8M,aAGjD0E,cAAA,kBACS/U,KAAK8S,cAGdgC,iBAAA,kBACS9U,KAAKoQ,iBAGd4E,kBAAA,kBACShV,KAAKgL,kBAGdS,kBAAA,SAAkBlI,QACXyH,eAAiBzH,KAGxB0R,iBAAA,SACEzS,EACAe,OAEMe,EAAStE,KAAK+S,cAAc9F,MAChC,SAAApN,UAAK+D,EAAapB,KAAcoB,EAAa/D,EAAE2C,aAE7C8B,EACFA,EAAO0G,eAAiBzH,OAEnBwP,cAActT,KAAK,CAAE+C,SAAAA,EAAUwI,eAAgBzH,OAIxDmM,iBAAA,SACElN,gBAEOA,WACHxC,KAAK+S,cAAc9F,MAAK,SAAApN,UAAK2D,EAAgBhB,EAAU3C,EAAE2C,qBAAzD0S,EACIlK,oBACJvE,KAGN0O,oBAAA,SACElE,EACA1N,OAEMe,EAAStE,KAAKgT,iBAAiB/F,MACnC,SAAApN,UAAK+D,EAAaqN,KAAiBrN,EAAa/D,EAAEoR,gBAEhD3M,EACFA,EAAO0G,eAAiBzH,OAEnByP,iBAAiBvT,KAAK,CAAEwR,YAAAA,EAAajG,eAAgBzH,OAI9D2N,oBAAA,SACED,gBAEOA,WACHjR,KAAKgT,iBAAiB/F,MAAK,SAAApN,UACzB2D,EAAgByN,EAAapR,EAAEoR,wBADjCmE,EAEGpK,oBACHvE,KAGNgJ,oBAAA,SAA2DlM,YACrDA,SAAAA,EAAS8R,kBACJ9R,MAGHkQ,OACDzT,KAAKgL,eAAeoE,QACpBpP,KAAK0P,uBAAiBnM,SAAAA,EAASf,UAC/Be,GACH8R,YAAY,WAGT5B,EAAiBpQ,WAAaoQ,EAAiBjR,WAClDiR,EAAiBpQ,UAAYC,EAC3BmQ,EAAiBjR,SACjBiR,IAIGA,KAGT6B,4BAAA,SAEE/R,UACOvD,KAAKyP,oBAAoBlM,MAGlCyN,uBAAA,SACEzN,gBAEIA,SAAAA,EAAS8R,YACJ9R,OAGJvD,KAAKgL,eAAe8F,UACpB9Q,KAAKkR,0BAAoB3N,SAAAA,EAAS0N,aAClC1N,GACH8R,YAAY,OAIhBxF,MAAA,gBACOiD,WAAWjD,aACXO,cAAcP,cClcV0F,yBAyBThG,EACAhM,sCAIKgM,OAASA,IACThM,QAAUA,IACViS,aAAe,KACfC,gBACAxK,WAAW1H,uCAGRkS,YAAV,gBACO3J,OAAS9L,KAAK8L,OAAO4J,KAAK1V,WAC1BmN,QAAUnN,KAAKmN,QAAQuI,KAAK1V,SAGzBN,YAAV,WACgC,IAA1BM,KAAKX,UAAUY,cACZ0V,aAAatI,YAAYrN,MAE1B4V,EAAmB5V,KAAK2V,aAAc3V,KAAKuD,eACxCsS,oBAGFC,mBAIChW,cAAV,WACOE,KAAKX,UAAUY,aACbyM,aAITU,uBAAA,kBA4iBAvK,EA3iBgC7C,KAAK2V,cA+iBf,KAHtBpS,EA5iBmDvD,KAAKuD,SA+iB9CsJ,UACwB,WAA/BtJ,EAAQwS,qBACyB,IAA/BxS,EAAQwS,oBAAgCtS,EAAQZ,EAAOU,IAP9D,IACEV,EACAU,KAziBA2J,yBAAA,kBAmjBArK,EAljBkC7C,KAAK2V,cAsjBjB,KAHtBpS,EAnjBqDvD,KAAKuD,SAsjBhDsJ,UAC0B,WAAjCtJ,EAAQyS,uBAC2B,IAAjCzS,EAAQyS,sBAAkCvS,EAAQZ,EAAOU,IAPhE,IACEV,EACAU,KAhjBAmJ,QAAA,gBACOrN,UAAY,QACZ4W,mBACAN,aAAapI,eAAevN,SAGnCiL,WAAA,SACE1H,EACA2S,OAEMC,EAAcnW,KAAKuD,QACnB6S,EAAYpW,KAAK2V,qBAElBpS,QAAUvD,KAAKuP,OAAO+F,4BAA4B/R,QAGrB,IAAzBvD,KAAKuD,QAAQsJ,SACY,kBAAzB7M,KAAKuD,QAAQsJ,cAEd,IAAIwJ,MAAM,oCAIbrW,KAAKuD,QAAQf,gBACXe,QAAQf,SAAW2T,EAAY3T,eAGjC8T,kBAECC,EAAUvW,KAAKD,eAInBwW,GACAC,EACExW,KAAK2V,aACLS,EACApW,KAAKuD,QACL4S,SAGGN,oBAIFY,aAAaP,IAIhBK,GACCvW,KAAK2V,eAAiBS,GACrBpW,KAAKuD,QAAQsJ,UAAYsJ,EAAYtJ,SACrC7M,KAAKuD,QAAQzB,YAAcqU,EAAYrU,gBAEpC4U,sBAKLH,GACCvW,KAAK2V,eAAiBS,GACrBpW,KAAKuD,QAAQsJ,UAAYsJ,EAAYtJ,SACrC7M,KAAKuD,QAAQoT,kBAAoBR,EAAYQ,sBAE1CC,2BAITC,oBAAA,SACEtT,OAEMkQ,EAAmBzT,KAAKuP,OAAO+F,4BAA4B/R,GAE3DV,EAAQ7C,KAAKuP,OAChBwF,gBACAzF,MACCtP,KAAKuP,OACLkE,UAGGzT,KAAK8W,aAAajU,EAAO4Q,MAGlC1G,iBAAA,kBACS/M,KAAK+W,iBAGdC,YAAA,SACE1S,cAEM2S,EAAgB,UAEtBjY,OAAOmF,KAAKG,GAAQgC,SAAQ,SAAA9F,GAC1BxB,OAAOkY,eAAeD,EAAezW,EAAK,CACxC2W,cAAc,EACdC,YAAY,EACZ5H,IAAK,eACG6H,EAAW7W,SACZ8J,EAAKkL,aAAa9O,SAAS2Q,IAC9B/M,EAAKkL,aAAa/V,KAAK4X,GAElB/S,EAAO+S,SAKbJ,KAGTK,cAAA,SACE/T,qBAEO,IAAIiC,SAAQ,SAACC,EAASqD,OACrByO,EAAchN,EAAKjL,WAAU,SAAAgF,GAC5BA,EAAOZ,aACV6T,IACIjT,EAAOkT,gBAAWjU,SAAAA,EAASgR,cAC7BzL,EAAOxE,EAAOsB,OAEdH,EAAQnB,aAOlBmT,gBAAA,kBACSzX,KAAK2V,gBAGd7J,OAAA,gBACOyD,OAAOwF,gBAAgBjJ,OAAO9L,KAAK2V,iBAG1CxI,QAAA,SACE5J,UAEOvD,KAAKyN,MAAMlK,MAGpBmU,gBAAA,SACEnU,cAEMkQ,EAAmBzT,KAAKuP,OAAO+F,4BAA4B/R,GAE3DV,EAAQ7C,KAAKuP,OAChBwF,gBACAzF,MACCtP,KAAKuP,OACLkE,UAGG5Q,EAAM4K,QAAQ/H,MAAK,kBAAMsK,EAAK8G,aAAajU,EAAO4Q,SAGjDhG,MAAV,SACEC,qBAEO1N,KAAK6V,aAAanI,GAAchI,MAAK,kBAC1CuK,EAAKwG,eACExG,EAAK8G,oBAIRlB,aAAR,SACEnI,QAGK4I,kBAGD5N,EAA2C1I,KAAK2V,aAAalI,MAC/DzN,KAAKuD,QACLmK,gBAGGA,SAAAA,EAAc6G,gBACjB7L,EAAUA,EAAQ/C,MAAM7E,IAGnB4H,KAGDgO,mBAAR,8BACOiB,qBAGH/W,IACAZ,KAAK+W,cAActT,SAClBvC,EAAelB,KAAKuD,QAAQzB,gBAYzBqH,EAPOvH,EACX5B,KAAK+W,cAAcxK,cACnBvM,KAAKuD,QAAQzB,WAKQ,OAElB8V,eAAiB/R,YAAW,WAC1BgP,EAAKkC,cAActT,SACtBoR,EAAK4B,iBAENtN,OAGGyN,sBAAR,2BACOiB,wBAGHjX,IACyB,IAAzBZ,KAAKuD,QAAQsJ,SACZ3L,EAAelB,KAAKuD,QAAQoT,wBAK1BmB,kBAAoBC,aAAY,YAEjCC,EAAKzU,QAAQ0U,6BACbnS,EAAaS,cAEbyR,EAAKnC,iBAEN7V,KAAKuD,QAAQoT,qBAGVb,aAAR,gBACOY,0BACAE,2BAGCX,YAAR,gBACO0B,yBACAE,0BAGCF,kBAAR,WACE9L,aAAa7L,KAAK4X,qBACbA,oBAAiBnR,KAGhBoR,qBAAR,WACEK,cAAclY,KAAK8X,wBACdA,uBAAoBrR,KAGjBqQ,aAAV,SACEjU,EACAU,OAmBI0I,EAiEEkM,EAlFA/B,EAAYpW,KAAK2V,aACjBQ,EAAcnW,KAAKuD,QACnB6U,EAAapY,KAAK+W,cAClBsB,EAAkBrY,KAAKsY,mBACvBC,EAAoBvY,KAAKwY,qBACzBC,EAAc5V,IAAUuT,EACxBsC,EAAoBD,EACtB5V,EAAMwI,MACNrL,KAAK2Y,yBACHC,EAAkBH,EACpBzY,KAAK+W,cACL/W,KAAK6Y,oBAEDxN,EAAUxI,EAAVwI,MACFkB,EAA6DlB,EAA7DkB,cAAe3G,EAA8CyF,EAA9CzF,MAAOoJ,EAAuC3D,EAAvC2D,eAAgBtL,EAAuB2H,EAAvB3H,WAAYwL,EAAW7D,EAAX6D,OACpD4J,GAAiB,EACjBC,GAAoB,KAIpBxV,EAAQyV,kBAAmB,KACvBzC,EAAUvW,KAAKD,eAEfkZ,GAAgB1C,GAAWX,EAAmB/S,EAAOU,GAErD2V,EACJ3C,GAAWC,EAAsB3T,EAAOuT,EAAW7S,EAAS4S,IAE1D8C,GAAgBC,KAClBxV,GAAa,EACR6I,IACH2C,EAAS,eAOb3L,EAAQ4V,mBACP9N,EAAMyD,wBACP8J,SAAAA,EAAiBQ,YACN,UAAXlK,EAEAjD,EAAO2M,EAAgB3M,KACvBM,EAAgBqM,EAAgBrM,cAChC2C,EAAS0J,EAAgB1J,OACzB4J,GAAiB,OAGd,GAAIvV,EAAQ8V,aAAgC,IAAfhO,EAAMY,QAGpCmM,GACA/M,EAAMY,cAASoM,SAAAA,EAAiBpM,OAChC1I,EAAQ8V,gBAAWd,SAAAA,EAAmBc,QAEtCpN,EAAOmM,EAAWnM,cAGhBA,EAAO1I,EAAQ8V,OAAOhO,EAAMY,OACM,IAA9B1I,EAAQ6I,oBACVH,EAAOtH,QAAiByT,SAAAA,EAAYnM,KAAMA,IAE5C,MAAOqN,GACPxO,IAAYlF,MAAM0T,GAClB1T,EAAQ0T,EACRtK,EAAiB/M,KAAKC,MACtBgN,EAAS,aAMbjD,EAAQZ,EAAMY,UAKqB,IAA5B1I,EAAQ4U,sBACC,IAATlM,GACI,YAAXiD,SAiB+B,KAR7BiJ,SAHAC,SAAAA,EAAYW,oBACZxV,EAAQ4U,yBAAoBI,SAAAA,EAAmBJ,iBAE7BC,EAAWnM,KAGQ,mBAA5B1I,EAAQ4U,gBACV5U,EAAQ4U,kBACT5U,EAAQ4U,mBAIdjJ,EAAS,UACTjD,EAAOkM,EACPY,GAAoB,UAI+B,CACrD7J,OAAAA,EACAqK,UAAsB,YAAXrK,EACXkK,UAAsB,YAAXlK,EACXsI,QAAoB,UAAXtI,EACTsK,OAAmB,SAAXtK,EACRjD,KAAAA,EACAM,cAAAA,EACA3G,MAAAA,EACAoJ,eAAAA,EACA1H,aAAc+D,EAAM4D,kBACpBwK,UAAWpO,EAAMyD,gBAAkB,GAAKzD,EAAM0D,iBAAmB,EACjE2K,oBACErO,EAAMyD,gBAAkB4J,EAAkB5J,iBAC1CzD,EAAM0D,iBAAmB2J,EAAkB3J,iBAC7CrL,WAAAA,EACAiW,eAA2B,UAAXzK,GAA8C,IAAxB7D,EAAMkB,cAC5CwM,kBAAAA,EACAD,eAAAA,EACAc,eAA2B,UAAX1K,GAA8C,IAAxB7D,EAAMkB,cAC5C9I,QAASA,EAAQZ,EAAOU,GACxB4J,QAASnN,KAAKmN,QACdrB,OAAQ9L,KAAK8L,WAMT+N,sBAAR,SACEvV,EACA8T,OAEKA,SACI,KAGL9T,IAAW8T,SACN,QAGsDpY,KAAKuD,QAA5DuW,IAAAA,oBAAqBC,IAAAA,kCAExBD,IAAwBC,SACpB,KAGmB,YAAxBD,IAAsC9Z,KAAKwV,aAAavV,cACnD,MAGH+Z,EACoB,YAAxBF,EACI9Z,KAAKwV,aACLsE,SAEC9a,OAAOmF,KAAKG,GAAQI,MAAK,SAAAlE,OACxB6W,EAAW7W,EACXyZ,EAAU3V,EAAO+S,KAAce,EAAWf,GAC1C6C,QAAaF,SAAAA,EAAetV,MAAK,SAAA7E,UAAKA,IAAMW,KAC5C2Z,QAAaJ,SAAAA,EAA+BrV,MAAK,SAAA7E,UAAKA,IAAMW,YAC3DyZ,IAAYE,KAAgBH,GAAiBE,SAIxDzD,aAAA,SAAaP,OACLkC,EAAapY,KAAK+W,sBAInBA,cAAgB/W,KAAK8W,aAAa9W,KAAK2V,aAAc3V,KAAKuD,cAC1D+U,mBAAqBtY,KAAK2V,aAAatK,WACvCmN,qBAAuBxY,KAAKuD,SZzP9B,SAAgCgB,EAAMC,MACtCD,IAAMC,GAAOA,IAAMD,SACf,MAGJ,IAAM/D,KAAO+D,KACZA,EAAE/D,KAASgE,EAAEhE,UACR,SAIJ,EYiPD4Z,CAAoBpa,KAAK+W,cAAeqB,QAKtCiC,EAAsC,CAAElP,OAAO,IAGtB,WAA7B+K,SAAAA,EAAe7W,YACfW,KAAK6Z,sBAAsB7Z,KAAK+W,cAAeqB,KAE/CiC,EAAqBhb,WAAY,QAG9BiO,YAAY+M,EAAyBnE,QAGpCI,YAAR,eACQzT,EAAQ7C,KAAKuP,OAChBwF,gBACAzF,MACCtP,KAAKuP,OACLvP,KAAKuD,YAGLV,IAAU7C,KAAK2V,kBAIbS,EAAYpW,KAAK2V,kBAClBA,aAAe9S,OACf8V,yBAA2B9V,EAAMwI,WACjCwN,oBAAsB7Y,KAAK+W,cAE5B/W,KAAKD,uBACPqW,GAAAA,EAAW7I,eAAevN,MAC1B6C,EAAMwK,YAAYrN,WAItB0O,cAAA,SAAcF,OACN0H,EAA+B,GAEjB,YAAhB1H,EAAOlC,KACT4J,EAAcrN,WAAY,EACD,UAAhB2F,EAAOlC,OAChB4J,EAAcnN,SAAU,QAGrB0N,aAAaP,GAEdlW,KAAKD,qBACF+V,kBAIDxI,OAAR,SAAe4I,cACbtM,EAAcK,OAAM,WAEdiM,EAAcrN,iBAChByR,EAAK/W,QAAQsF,WAAbyR,EAAK/W,QAAQsF,UAAYyR,EAAKvD,cAAc9K,YAC5CqO,EAAK/W,QAAQmN,WAAb4J,EAAK/W,QAAQmN,UAAY4J,EAAKvD,cAAc9K,KAAO,OAC1CiK,EAAcnN,gBACvBuR,EAAK/W,QAAQwF,SAAbuR,EAAK/W,QAAQwF,QAAUuR,EAAKvD,cAAcnR,aAC1C0U,EAAK/W,QAAQmN,WAAb4J,EAAK/W,QAAQmN,eAAYjK,EAAW6T,EAAKvD,cAAcnR,QAIrDsQ,EAAc7W,WAChBib,EAAKjb,UAAUiH,SAAQ,SAAA/G,GACrBA,EAAS+a,EAAKvD,kBAKdb,EAAc/K,OAChBmP,EAAK/K,OAAOwF,gBAAgBzH,OAAOgN,EAAK3E,qBA5jBtCvW,GAylBV,SAASwW,EACP/S,EACAU,UAzBF,SACEV,EACAU,YAGsB,IAApBA,EAAQsJ,SACPhK,EAAMwI,MAAMkB,eACY,UAAvB1J,EAAMwI,MAAM6D,SAA+C,IAAzB3L,EAAQgX,cAqB5CC,CAAkB3X,EAAOU,IAjB7B,SACEV,EACAU,UAGsB,IAApBA,EAAQsJ,SACRhK,EAAMwI,MAAMkB,cAAgB,IACA,WAA3BhJ,EAAQkX,iBACqB,IAA3BlX,EAAQkX,gBAA4BhX,EAAQZ,EAAOU,IASjBmX,CAAqB7X,EAAOU,GA0BrE,SAASiT,EACP3T,EACAuT,EACA7S,EACA4S,UAGsB,IAApB5S,EAAQsJ,UACPhK,IAAUuT,IAAqC,IAAxBD,EAAYtJ,UACpCpJ,EAAQZ,EAAOU,GAInB,SAASE,EACPZ,EACAU,UAEOV,EAAMmK,cAAczJ,EAAQzB,eC5qBxB6Y,yBAOCpL,EAAqBH,sCAG1BG,OAASA,IACTH,QAAU,KACV9K,OAAS,KACT4G,UAAY,KACZ0P,aAAe,GAEhBxL,KACGyL,WAAWzL,uCAIV1P,YAAV,sBACgC,IAA1BM,KAAKX,UAAUY,aACZiL,UAAU5E,SAAQ,SAAAsG,GACrBA,EAAStN,WAAU,SAAAgF,GACjBgG,EAAKwQ,SAASlO,EAAUtI,YAMtBxE,cAAV,WACOE,KAAKX,UAAUY,aACbyM,aAITA,QAAA,gBACOrN,UAAY,QACZ6L,UAAU5E,SAAQ,SAAAsG,GACrBA,EAASF,gBAIbmO,WAAA,SACEzL,EACA8G,QAEK9G,QAAUA,OACV2L,gBAAgB7E,MAGvBnJ,iBAAA,kBACS/M,KAAKsE,UAGduS,oBAAA,SAAoBzH,qBACXA,EAAQ8E,KAAI,SAAA3Q,OACXkQ,EAAmBlJ,EAAKgF,OAAO+F,4BAA4B/R,UAC1DgH,EAAKyQ,YAAYvH,GAAkBoD,oBACxCpD,SAKEuH,YAAR,SAAoBzX,OACZkQ,EAAmBzT,KAAKuP,OAAO+F,4BAA4B/R,UAE/DvD,KAAK4a,aAAanH,EAAiBpQ,YACnC,IAAIkS,EAAcvV,KAAKuP,OAAQkE,MAI3BsH,gBAAR,SAAwB7E,cACtBtM,EAAcK,OAAM,eACdgR,GAAiB,EAEfC,EAAgBlL,EAAK9E,UACrBiQ,EAAkBnL,EAAK4K,aAEvBQ,EAAmC,GACnCC,EAAgC,GAChCC,EAAiD,GAEvDtL,EAAKZ,QAAQ9I,SAAQ,SAAC/C,EAASlD,OACvBoT,EAAmBzD,EAAKT,OAAO+F,4BACnC/R,GAEIF,EAAYoQ,EAAiBpQ,UAC7BuJ,EAAWoD,EAAKgL,YAAYvH,GAE9B0H,EAAgB9X,IAClBuJ,EAAS3B,WAAWwI,EAAkByC,GAGpCtJ,IAAasO,EAAc7a,KAC7B4a,GAAiB,GAGnBI,EAAa5b,KAAKmN,GAClBwO,EAAU3b,KAAKmN,EAASG,oBACxBuO,EAAgBjY,GAAauJ,MAG3BsO,EAAcjb,SAAWob,EAAapb,QAAWgb,KAIrDjL,EAAK9E,UAAYmQ,EACjBrL,EAAK4K,aAAeU,EACpBtL,EAAK1L,OAAS8W,EAETpL,EAAKjQ,iBAIVyB,EAAW0Z,EAAeG,GAAc/U,SAAQ,SAAAsG,GAC9CA,EAASF,aAGXlL,EAAW6Z,EAAcH,GAAe5U,SAAQ,SAAAsG,GAC9CA,EAAStN,WAAU,SAAAgF,GACjB0L,EAAK8K,SAASlO,EAAUtI,SAI5B0L,EAAK1C,iBAIDwN,SAAR,SAAiBlO,EAAyBtI,OAClCiX,EAAQvb,KAAKkL,UAAUvJ,QAAQiL,IACtB,IAAX2O,SACGjX,ObhEJ,SAAsBM,EAAY2W,EAAepa,OAChD6D,EAAOJ,EAAM4W,MAAM,UACzBxW,EAAKuW,GAASpa,EACP6D,Ea6DWyW,CAAUzb,KAAKsE,OAAQiX,EAAOjX,QACvCgJ,aAIDA,OAAR,sBACE1D,EAAcK,OAAM,WAClBgG,EAAK5Q,UAAUiH,SAAQ,SAAA/G,GACrBA,EAAS0Q,EAAK3L,kBA7IelF,GCWxBsc,yBA0BTnM,EACAhM,UAOAoY,YAAMpM,EAAQhM,2CAGNkS,YAAV,uBACQA,4BACDmG,cAAgB5b,KAAK4b,cAAclG,KAAK1V,WACxC6b,kBAAoB7b,KAAK6b,kBAAkBnG,KAAK1V,SAGvDiL,WAAA,SACE1H,eAOM0H,0BACD1H,GACHyK,SAAUqD,UAIduK,cAAA,SACErY,UAEOvD,KAAKyN,MAAM,CAChBE,eAAe,EACf4G,mBAAchR,SAAAA,EAASgR,aACvBjG,KAAM,CACJgD,UAAW,CAAEE,UAAW,UAAW3D,gBAAWtK,SAAAA,EAASsK,iBAK7DgO,kBAAA,SACEtY,UAEOvD,KAAKyN,MAAM,CAChBE,eAAe,EACf4G,mBAAchR,SAAAA,EAASgR,aACvBjG,KAAM,CACJgD,UAAW,CAAEE,UAAW,WAAY3D,gBAAWtK,SAAAA,EAASsK,iBAKpDiJ,aAAV,SACEjU,EACAU,mBAOQ8H,EAAUxI,EAAVwI,8BACayL,uBAAajU,EAAOU,IAGvCqY,cAAe5b,KAAK4b,cACpBC,kBAAmB7b,KAAK6b,kBACxBpJ,YAAaA,EAAYlP,WAAS8H,EAAMY,aAAN6P,EAAYnK,OAC9CgB,gBAAiBA,EAAgBpP,WAAS8H,EAAMY,aAAN8P,EAAYpK,OACtDJ,mBACElG,EAAM3H,YAAwD,sBAA1C2H,EAAM+C,uBAAWkD,oBAAWE,WAClDC,uBACEpG,EAAM3H,YACoC,uBAA1C2H,EAAM+C,uBAAWkD,oBAAWE,iBAjG1B+D,GCDGyG,yBAqBTzM,EACAhM,sCAIKgM,OAASA,IACTtE,WAAW1H,KACXkS,gBACAgB,mDAGGhB,YAAV,gBACOwG,OAASjc,KAAKic,OAAOvG,KAAK1V,WAC1B2M,MAAQ3M,KAAK2M,MAAM+I,KAAK1V,SAG/BiL,WAAA,SACE1H,QAEKA,QAAUvD,KAAKuP,OAAOyB,uBAAuBzN,MAG1CzD,cAAV,iBACOE,KAAKX,UAAUY,uBACbic,oBAAiB3O,eAAevN,UAIzC4Q,iBAAA,SAAiBpC,QACViI,mBAGCP,EAA+B,CACnC7W,WAAW,GAGO,YAAhBmP,EAAOlC,KACT4J,EAAcrN,WAAY,EACD,UAAhB2F,EAAOlC,OAChB4J,EAAcnN,SAAU,QAGrBuE,OAAO4I,MAGdnJ,iBAAA,kBAMS/M,KAAK+W,iBAGdpK,MAAA,gBACOuP,qBAAkBzV,OAClBgQ,oBACAnJ,OAAO,CAAEjO,WAAW,OAG3B4c,OAAA,SACE1L,EACAhN,eAEK4Y,cAAgB5Y,EAEjBvD,KAAKkc,sBACFA,gBAAgB3O,eAAevN,WAGjCkc,gBAAkBlc,KAAKuP,OAAOuF,mBAAmBxF,MAAMtP,KAAKuP,YAC5DvP,KAAKuD,SACRgN,eACuB,IAAdA,EAA4BA,EAAYvQ,KAAKuD,QAAQgN,kBAG3D2L,gBAAgB7O,YAAYrN,MAE1BA,KAAKkc,gBAAgB7L,aAGtBoG,aAAR,eACQpL,EAAQrL,KAAKkc,gBACflc,KAAKkc,gBAAgB7Q,MPiIpB,CACLyC,aAASrH,EACTwF,UAAMxF,EACNb,MAAO,KACP0B,aAAc,EACdiB,UAAU,EACV2G,OAAQ,OACRqB,eAAW9J,QOrINsQ,mBACA1L,GACHkO,UAA4B,YAAjBlO,EAAM6D,OACjBkK,UAA4B,YAAjB/N,EAAM6D,OACjBsI,QAA0B,UAAjBnM,EAAM6D,OACfsK,OAAyB,SAAjBnO,EAAM6D,OACd+M,OAAQjc,KAAKic,OACbtP,MAAO3M,KAAK2M,WAIRW,OAAR,SAAe/J,cACbqG,EAAcK,OAAM,WAEdK,EAAK6R,gBACH5Y,EAAQsF,iBACVyB,EAAK6R,cAActT,WAAnByB,EAAK6R,cAActT,UACjByB,EAAKyM,cAAc9K,KACnB3B,EAAKyM,cAAcxG,UACnBjG,EAAKyM,cAAcjJ,eAErBxD,EAAK6R,cAAczL,WAAnBpG,EAAK6R,cAAczL,UACjBpG,EAAKyM,cAAc9K,KACnB,KACA3B,EAAKyM,cAAcxG,UACnBjG,EAAKyM,cAAcjJ,UAEZvK,EAAQwF,gBACjBuB,EAAK6R,cAAcpT,SAAnBuB,EAAK6R,cAAcpT,QACjBuB,EAAKyM,cAAcnR,MACnB0E,EAAKyM,cAAcxG,UACnBjG,EAAKyM,cAAcjJ,eAErBxD,EAAK6R,cAAczL,WAAnBpG,EAAK6R,cAAczL,eACjBjK,EACA6D,EAAKyM,cAAcnR,MACnB0E,EAAKyM,cAAcxG,UACnBjG,EAAKyM,cAAcjJ,WAMrBvK,EAAQlE,WACViL,EAAKjL,UAAUiH,SAAQ,SAAA/G,GACrBA,EAAS+K,EAAKyM,yBAnJd3X,GCnBJgd,EAAiBC,EAAMC,mBAAuC7V,GAQpE,SAAS8V,UAEe,oBAAX1b,QACJA,OAAO2b,0BACV3b,OAAO2b,wBAA0BJ,GAG5Bvb,OAAO2b,yBAGTJ,MAGIK,EAAiB,eACtBC,EAAcL,EAAMM,WAAWJ,SAEhCG,QACG,IAAIrG,MAAM,iEAGXqG,GC5BT,SAASE,SACHC,GAAU,QACP,CACLC,WAAY,WACVD,GAAU,GAEZlQ,MAAO,WACLkQ,GAAU,GAEZA,QAAS,kBACAA,IAKb,IAAME,GAAiCV,EAAMC,cAAcM,MAI9CI,GAA6B,kBACxCX,EAAMM,WAAWI,KCtBZ,SAASE,GACd1Z,EACA2Z,OAEMC,EAAad,EAAMe,QAAO,GACvBC,EAAehB,EAAMiB,SAAS,MAEjCZ,EAAcD,IACdc,EAAqBP,KACrBvJ,EAAmBiJ,EAAYpH,4BAA4B/R,GAGjEkQ,EAAiBuF,mBAAoB,EAGjCvF,EAAiB1K,UACnB0K,EAAiB1K,QAAUa,EAAcQ,WACvCqJ,EAAiB1K,UAIjB0K,EAAiB5K,YACnB4K,EAAiB5K,UAAYe,EAAcQ,WACzCqJ,EAAiB5K,YAIjB4K,EAAiB/C,YACnB+C,EAAiB/C,UAAY9G,EAAcQ,WACzCqJ,EAAiB/C,YAIjB+C,EAAiB+J,UAGuB,iBAA/B/J,EAAiB3R,YAC1B2R,EAAiB3R,UAAY,MAI7B2R,EAAiB+J,UAAY/J,EAAiBgK,oBAE3CF,EAAmBV,YACtBpJ,EAAiB8G,cAAe,QAI9BmD,EAASrB,EAAMe,SAEhBM,EAAOC,UACVD,EAAOC,QAAU,IAAIT,EAASR,EAAajJ,QAGzCnP,EAASoZ,EAAOC,QAAQ9G,oBAAoBpD,MAEhD4I,EAAMuB,WAAU,WACdT,EAAWQ,SAAU,EAErBJ,EAAmBT,iBAEbvF,EAAcmG,EAAOC,QAASre,UAClCsK,EAAcQ,YAAW,WACnB+S,EAAWQ,SACbN,GAAY,SAAAxd,UAAKA,EAAI,gBAO3B6d,EAAOC,QAASlH,eAET,WACL0G,EAAWQ,SAAU,EACrBpG,OAED,CAACgG,IAEJlB,EAAMuB,WAAU,WAGdF,EAAOC,QAAS1S,WAAWwI,EAAkB,CAAEpU,WAAW,MACzD,CAACoU,IAGAA,EAAiB+J,UAAYlZ,EAAOiV,gBAChCmE,EAAOC,QACVjG,gBAAgBjE,GAChB/N,MAAK,gBAAGuG,IAAAA,WACPwH,EAAiB5K,WAAjB4K,EAAiB5K,UAAYoD,SAC7BwH,EAAiB/C,WAAjB+C,EAAiB/C,UAAYzE,EAAM,SAEpCtG,OAAM,SAAAC,GACL2X,EAAmBT,mBACnBrJ,EAAiB1K,SAAjB0K,EAAiB1K,QAAUnD,SAC3B6N,EAAiB/C,WAAjB+C,EAAiB/C,eAAYjK,EAAWb,UAM3C6N,EAAiB+J,UAAY/J,EAAiBgK,mBAC/CnZ,EAAOkT,cAEDlT,EAAOsB,YAI8B,YAAzC6N,EAAiBqG,sBACnBxV,EAASoZ,EAAOC,QAAQ3G,YAAY1S,IAG/BA,+JF5E8D,gBACrEiL,IAAAA,OACAsO,IAAAA,SAEAxB,EAAMuB,WAAU,kBACdrO,EAAO0D,QACA,WACL1D,EAAO6D,aAER,CAAC7D,QAEEuO,EAAUvB,WAETF,gBAACyB,EAAQC,UAAS5c,MAAOoO,GAASsO,8BClBoC,gBAC7EA,IAAAA,SAEM1c,EAAQkb,EAAM2B,SAAQ,kBAAMpB,OAAe,WAE/CP,gBAACU,GAA+BgB,UAAS5c,MAAOA,GACzB,mBAAb0c,EACHA,EAAsB1c,GACvB0c,uFjBiSH,SAAiB1c,UACfA,aAAiBkV,uDK1TnB,SAAmB4H,GACxBvT,EAASuT,sBcQJ,SACL7b,EACAC,EAGAC,UAGO2a,GADS9a,EAAeC,EAAMC,EAAMC,GAGzCoZ,oBC/BG,SACLtZ,EACAC,OAEM8a,EAAad,EAAMe,QAAO,GAE1BV,EAAcD,IAEb7Z,EAAWF,EAAgBN,EAAMC,QACJga,EAAMiB,SACxCZ,EAAYhZ,WAAWd,IADlBc,OAAYwa,OAIbC,EAAa9B,EAAMe,OAAOxa,GAChCub,EAAWR,QAAU/a,MACfwb,EAAgB/B,EAAMe,OAAO1Z,UACnC0a,EAAcT,QAAUja,EAExB2Y,EAAMuB,WAAU,WACdT,EAAWQ,SAAU,MAEfpG,EAAcmF,EAAY3H,gBAAgBzV,UAC9CsK,EAAcQ,YAAW,cACnB+S,EAAWQ,QAAS,KAChBU,EAAgB3B,EAAYhZ,WAAWya,EAAWR,SACpDS,EAAcT,UAAYU,GAC5BH,EAAcG,eAMf,WACLlB,EAAWQ,SAAU,EACrBpG,OAED,CAACmF,IAEGhZ,iBCCF,SAMLtB,EAIAC,EAGAC,OAEM6a,EAAad,EAAMe,QAAO,GACvBC,EAAehB,EAAMiB,SAAS,MAEjC/Z,ErBmCD,SAGLnB,EACAC,EACAC,UAEIC,EAAWH,GACO,mBAATC,OACGC,GAAM2O,YAAa7O,EAAMuO,WAAYtO,SAEvCA,GAAM4O,YAAa7O,IAGb,mBAATA,OACGC,GAAMsO,WAAYvO,SAGpBA,GqBrDIkc,CAAkBlc,EAAMC,EAAMC,GACxCoa,EAAcD,IAEdiB,EAASrB,EAAMe,SAEhBM,EAAOC,QAGVD,EAAOC,QAAQ1S,WAAW1H,GAF1Bma,EAAOC,QAAU,IAAI3B,EAAiBU,EAAanZ,OAK/CwT,EAAgB2G,EAAOC,QAAQ5Q,mBAErCsP,EAAMuB,WAAU,WACdT,EAAWQ,SAAU,MAEfpG,EAAcmG,EAAOC,QAASre,UAClCsK,EAAcQ,YAAW,WACnB+S,EAAWQ,SACbN,GAAY,SAAAxd,UAAKA,EAAI,gBAIpB,WACLsd,EAAWQ,SAAU,EACrBpG,OAED,QAEG0E,EAASI,EAAMkC,aAEnB,SAAChO,EAAW4L,GACZuB,EAAOC,QAAS1B,OAAO1L,EAAW4L,GAAexW,MAAM7E,KACtD,OAECiW,EAAcnR,OAAS8X,EAAOC,QAAQpa,QAAQka,uBAC1C1G,EAAcnR,kBAGVmR,GAAekF,OAAAA,EAAQuC,YAAazH,EAAckF,uBCrGzD,SAAoB7M,OACnB+N,EAAad,EAAMe,QAAO,GACvBC,EAAehB,EAAMiB,SAAS,MAEjCZ,EAAcD,IAEdgC,EAAmBrP,EAAQ8E,KAAI,SAAA3Q,OAC7BkQ,EAAmBiJ,EAAYpH,4BAA4B/R,UAGjEkQ,EAAiBuF,mBAAoB,EAE9BvF,KAGHiK,EAASrB,EAAMe,SAEhBM,EAAOC,UACVD,EAAOC,QAAU,IAAIhD,EAAgB+B,EAAa+B,QAG9Cna,EAASoZ,EAAOC,QAAQ9G,oBAAoB4H,UAElDpC,EAAMuB,WAAU,WACdT,EAAWQ,SAAU,MAEfpG,EAAcmG,EAAOC,QAASre,UAClCsK,EAAcQ,YAAW,WACnB+S,EAAWQ,SACbN,GAAY,SAAAxd,UAAKA,EAAI,gBAKpB,WACLsd,EAAWQ,SAAU,EACrBpG,OAED,IAEH8E,EAAMuB,WAAU,WAGdF,EAAOC,QAAS9C,WAAW4D,EAAkB,CAAEpf,WAAW,MACzD,CAACof,IAEGna,cCrBF,SACLlC,EACAC,EAGAC,UAGO2a,GADe9a,EAAeC,EAAMC,EAAMC,GACdiT"}